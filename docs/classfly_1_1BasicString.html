<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libfly: fly::BasicString&lt; StringType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libfly
   &#160;<span id="projectnumber">5.0.0</span>
   </div>
   <div id="projectbrief">C++20 utility library for Linux, macOS, and Windows</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classfly_1_1BasicString.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classfly_1_1BasicString-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fly::BasicString&lt; StringType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="string_8hpp_source.html">string.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac0299f259b603a93ee1764eeea2a2e65"><td class="memItemLeft" align="right" valign="top"><a id="ac0299f259b603a93ee1764eeea2a2e65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>string_type</b> = typename <a class="el" href="structfly_1_1detail_1_1BasicStringTraits.html#a7964422bfc4414d79060e8611736136f">traits::string_type</a></td></tr>
<tr class="separator:ac0299f259b603a93ee1764eeea2a2e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043262c1e9036c1e21d259cd29f63a67"><td class="memItemLeft" align="right" valign="top"><a id="a043262c1e9036c1e21d259cd29f63a67"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename traits::size_type</td></tr>
<tr class="separator:a043262c1e9036c1e21d259cd29f63a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c91d41decb706d2c1a2f7ee24822faf"><td class="memItemLeft" align="right" valign="top"><a id="a1c91d41decb706d2c1a2f7ee24822faf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>char_type</b> = typename traits::char_type</td></tr>
<tr class="separator:a1c91d41decb706d2c1a2f7ee24822faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c87860256a700d17ab5996b1bcdc03"><td class="memItemLeft" align="right" valign="top"><a id="af9c87860256a700d17ab5996b1bcdc03"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>view_type</b> = typename traits::view_type</td></tr>
<tr class="separator:af9c87860256a700d17ab5996b1bcdc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ebf1e67486e2ba54e5714614d57ecc"><td class="memItemLeft" align="right" valign="top"><a id="a97ebf1e67486e2ba54e5714614d57ecc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>int_type</b> = typename traits::int_type</td></tr>
<tr class="separator:a97ebf1e67486e2ba54e5714614d57ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786dbb21f82129fccc66d709f29950c6"><td class="memItemLeft" align="right" valign="top"><a id="a786dbb21f82129fccc66d709f29950c6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>codepoint_type</b> = typename traits::codepoint_type</td></tr>
<tr class="separator:a786dbb21f82129fccc66d709f29950c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f65912079aedbffd92cabc8e6bc293b"><td class="memTemplParams" colspan="2"><a id="a9f65912079aedbffd92cabc8e6bc293b"></a>
template&lt;typename... ParameterTypes&gt; </td></tr>
<tr class="memitem:a9f65912079aedbffd92cabc8e6bc293b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FormatString</b> = <a class="el" href="classfly_1_1detail_1_1BasicFormatString.html">detail::BasicFormatString</a>&lt; StringType, std::type_identity_t&lt; ParameterTypes &gt;... &gt;</td></tr>
<tr class="separator:a9f65912079aedbffd92cabc8e6bc293b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af22199a7c8841ee6909bdc084508ce96"><td class="memTemplParams" colspan="2"><a id="af22199a7c8841ee6909bdc084508ce96"></a>
template&lt;typename T , enable_if&lt; detail::is_like_supported_string&lt; T &gt;&gt; &gt; </td></tr>
<tr class="memitem:af22199a7c8841ee6909bdc084508ce96"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>size</b> (T &amp;&amp;value) -&gt; size_type</td></tr>
<tr class="separator:af22199a7c8841ee6909bdc084508ce96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cfd5c0a2305dbe1d5ae434ed2c6d1d"><td class="memTemplParams" colspan="2"><a id="a26cfd5c0a2305dbe1d5ae434ed2c6d1d"></a>
template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a26cfd5c0a2305dbe1d5ae434ed2c6d1d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>decode_codepoint</b> (IteratorType &amp;it, const IteratorType &amp;end) -&gt; std::optional&lt; codepoint_type &gt;</td></tr>
<tr class="separator:a26cfd5c0a2305dbe1d5ae434ed2c6d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a01ce84a290b7d8f062e4df728902abfa"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if&lt; detail::is_like_supported_string&lt; T &gt;&gt;  = 0&gt; </td></tr>
<tr class="memitem:a01ce84a290b7d8f062e4df728902abfa"><td class="memTemplItemLeft" align="right" valign="top">static constexpr size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a01ce84a290b7d8f062e4df728902abfa">size</a> (T &amp;&amp;value)</td></tr>
<tr class="separator:a01ce84a290b7d8f062e4df728902abfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e50bb6745db448761589840ba8d2492"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a7e50bb6745db448761589840ba8d2492">is_alpha</a> (char_type ch)</td></tr>
<tr class="separator:a7e50bb6745db448761589840ba8d2492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a7f2d674c1390805e02c4e1b4af19e"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#ac2a7f2d674c1390805e02c4e1b4af19e">is_upper</a> (char_type ch)</td></tr>
<tr class="separator:ac2a7f2d674c1390805e02c4e1b4af19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d8a7ed3c089ff6403a5bb85a1947fd"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#ac7d8a7ed3c089ff6403a5bb85a1947fd">is_lower</a> (char_type ch)</td></tr>
<tr class="separator:ac7d8a7ed3c089ff6403a5bb85a1947fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe38a18a63ee464796607c8c187a31a"><td class="memItemLeft" align="right" valign="top">static constexpr char_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a1fe38a18a63ee464796607c8c187a31a">to_upper</a> (char_type ch)</td></tr>
<tr class="separator:a1fe38a18a63ee464796607c8c187a31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7223598069892ad8f701a6397ba7659"><td class="memItemLeft" align="right" valign="top">static constexpr char_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#ae7223598069892ad8f701a6397ba7659">to_lower</a> (char_type ch)</td></tr>
<tr class="separator:ae7223598069892ad8f701a6397ba7659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063bb471ab4167067a6302bac9e1a456"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a063bb471ab4167067a6302bac9e1a456">is_digit</a> (char_type ch)</td></tr>
<tr class="separator:a063bb471ab4167067a6302bac9e1a456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3e5bd7d7cc42418c5d888d83c6a36f"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a1c3e5bd7d7cc42418c5d888d83c6a36f">is_x_digit</a> (char_type ch)</td></tr>
<tr class="separator:a1c3e5bd7d7cc42418c5d888d83c6a36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf3375a7a732d25a2c28f46abd2c2b6"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#aacf3375a7a732d25a2c28f46abd2c2b6">is_space</a> (char_type ch)</td></tr>
<tr class="separator:aacf3375a7a732d25a2c28f46abd2c2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7574cb70c8fbc106034225c4c0b45a25"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; StringType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a7574cb70c8fbc106034225c4c0b45a25">split</a> (view_type input, char_type delimiter)</td></tr>
<tr class="separator:a7574cb70c8fbc106034225c4c0b45a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82116d7a93abc2f5893bd478f2c25210"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; StringType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a82116d7a93abc2f5893bd478f2c25210">split</a> (view_type input, char_type delimiter, size_type count)</td></tr>
<tr class="separator:a82116d7a93abc2f5893bd478f2c25210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af012575a70e73bb819748add2929fb9f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#af012575a70e73bb819748add2929fb9f">trim</a> (StringType &amp;target)</td></tr>
<tr class="separator:af012575a70e73bb819748add2929fb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e262304fda915d1abfa76f3f31735d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#ac6e262304fda915d1abfa76f3f31735d">replace_all</a> (StringType &amp;target, view_type search, char_type replace)</td></tr>
<tr class="separator:ac6e262304fda915d1abfa76f3f31735d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcbd0e7603b9e1c0ddf9d3a17ce12d0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#afdcbd0e7603b9e1c0ddf9d3a17ce12d0">replace_all</a> (StringType &amp;target, view_type search, view_type replace)</td></tr>
<tr class="separator:afdcbd0e7603b9e1c0ddf9d3a17ce12d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad496bb598d50bcee52a560ab45621869"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#ad496bb598d50bcee52a560ab45621869">remove_all</a> (StringType &amp;target, view_type search)</td></tr>
<tr class="separator:ad496bb598d50bcee52a560ab45621869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c09b4a9ef6e0bd648babb1646ce0894"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a7c09b4a9ef6e0bd648babb1646ce0894">wildcard_match</a> (view_type source, view_type search)</td></tr>
<tr class="separator:a7c09b4a9ef6e0bd648babb1646ce0894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab7915d5010b7ce5508ce80d041689f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#adab7915d5010b7ce5508ce80d041689f">validate</a> (view_type value)</td></tr>
<tr class="separator:adab7915d5010b7ce5508ce80d041689f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66de183a9d9b0577b22539fd1b575dbe"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a66de183a9d9b0577b22539fd1b575dbe"><td class="memTemplItemLeft" align="right" valign="top">static std::optional&lt; codepoint_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a66de183a9d9b0577b22539fd1b575dbe">decode_codepoint</a> (IteratorType &amp;it, const IteratorType &amp;end)</td></tr>
<tr class="separator:a66de183a9d9b0577b22539fd1b575dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3abcf860054ae08ce0bc31ece349ab"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; StringType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a7f3abcf860054ae08ce0bc31ece349ab">encode_codepoint</a> (codepoint_type codepoint)</td></tr>
<tr class="separator:a7f3abcf860054ae08ce0bc31ece349ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4576b56e7b4b086512f02f86c19d42b4"><td class="memTemplParams" colspan="2">template&lt;char UnicodePrefix = 'U'&gt; </td></tr>
<tr class="memitem:a4576b56e7b4b086512f02f86c19d42b4"><td class="memTemplItemLeft" align="right" valign="top">static std::optional&lt; StringType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a4576b56e7b4b086512f02f86c19d42b4">escape_all_codepoints</a> (view_type value)</td></tr>
<tr class="separator:a4576b56e7b4b086512f02f86c19d42b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017b07c658e113e3b7bfb493b1855b2f"><td class="memTemplParams" colspan="2">template&lt;char UnicodePrefix = 'U', typename IteratorType &gt; </td></tr>
<tr class="memitem:a017b07c658e113e3b7bfb493b1855b2f"><td class="memTemplItemLeft" align="right" valign="top">static std::optional&lt; StringType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a017b07c658e113e3b7bfb493b1855b2f">escape_codepoint</a> (IteratorType &amp;it, const IteratorType &amp;end)</td></tr>
<tr class="separator:a017b07c658e113e3b7bfb493b1855b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1cd7927f49c82231891d5a722b739b"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; StringType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a8c1cd7927f49c82231891d5a722b739b">unescape_all_codepoints</a> (view_type value)</td></tr>
<tr class="separator:a8c1cd7927f49c82231891d5a722b739b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15fd6e9185f7bb3f1eb7e1473f86107"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:ab15fd6e9185f7bb3f1eb7e1473f86107"><td class="memTemplItemLeft" align="right" valign="top">static std::optional&lt; StringType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#ab15fd6e9185f7bb3f1eb7e1473f86107">unescape_codepoint</a> (IteratorType &amp;it, const IteratorType &amp;end)</td></tr>
<tr class="separator:ab15fd6e9185f7bb3f1eb7e1473f86107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae95f7f2e4dd207a9f42312c15dfc0b2"><td class="memItemLeft" align="right" valign="top">static StringType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#aae95f7f2e4dd207a9f42312c15dfc0b2">generate_random_string</a> (size_type length)</td></tr>
<tr class="separator:aae95f7f2e4dd207a9f42312c15dfc0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6f98cb3e4f612d23f9f309436499f9"><td class="memTemplParams" colspan="2">template&lt;typename... ParameterTypes&gt; </td></tr>
<tr class="memitem:aca6f98cb3e4f612d23f9f309436499f9"><td class="memTemplItemLeft" align="right" valign="top">static StringType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#aca6f98cb3e4f612d23f9f309436499f9">format</a> (<a class="el" href="classfly_1_1detail_1_1BasicFormatString.html">FormatString</a>&lt; ParameterTypes... &gt; &amp;&amp;fmt, ParameterTypes &amp;&amp;...parameters)</td></tr>
<tr class="separator:aca6f98cb3e4f612d23f9f309436499f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62209dbbae5f1faba54f5ed170c92086"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a62209dbbae5f1faba54f5ed170c92086"><td class="memTemplItemLeft" align="right" valign="top">static StringType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a62209dbbae5f1faba54f5ed170c92086">join</a> (char_type separator, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a62209dbbae5f1faba54f5ed170c92086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812cee25db27fc85801984dc4bbe1f52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a812cee25db27fc85801984dc4bbe1f52"><td class="memTemplItemLeft" align="right" valign="top">static std::optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1BasicString.html#a812cee25db27fc85801984dc4bbe1f52">convert</a> (const StringType &amp;value)</td></tr>
<tr class="separator:a812cee25db27fc85801984dc4bbe1f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename StringType&gt;<br />
class fly::BasicString&lt; StringType &gt;</h3>

<p>Forward declarations of the supported <a class="el" href="classfly_1_1BasicString.html">BasicString</a> specializations.</p>
<p>Static class to provide string utilities not provided by the STL.</p>
<dl class="section author"><dt>Author</dt><dd>Timothy Flynn (<a href="#" onclick="location.href='mai'+'lto:'+'trf'+'ly'+'nn8'+'9@'+'pm.'+'me'; return false;">trfly<span style="display: none;">.nosp@m.</span>nn89<span style="display: none;">.nosp@m.</span>@pm.m<span style="display: none;">.nosp@m.</span>e</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>March 21, 2019 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a812cee25db27fc85801984dc4bbe1f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812cee25db27fc85801984dc4bbe1f52">&#9670;&nbsp;</a></span>convert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::convert </td>
          <td>(</td>
          <td class="paramtype">const StringType &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a string to another type. The other type may be a string with a different Unicode encoding or a plain-old-data type, e.g. int or bool.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The desired type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, the string coverted to the specified type. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="a66de183a9d9b0577b22539fd1b575dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66de183a9d9b0577b22539fd1b575dbe">&#9670;&nbsp;</a></span>decode_codepoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;codepoint_type&gt; <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::decode_codepoint </td>
          <td>(</td>
          <td class="paramtype">IteratorType &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decode a single Unicode codepoint, starting at the character pointed to by the provided iterator. If successful, after invoking this method, that iterator will point at the first character after the Unicode codepoint in the source string.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IteratorType</td><td>The type of the encoded Unicode codepoint's iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Pointer to the beginning of the encoded Unicode codepoint. </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to the end of the encoded Unicode codepoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, the decoded Unicode codepoint. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="a7f3abcf860054ae08ce0bc31ece349ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3abcf860054ae08ce0bc31ece349ab">&#9670;&nbsp;</a></span>encode_codepoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; StringType &gt; <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::encode_codepoint </td>
          <td>(</td>
          <td class="paramtype">codepoint_type&#160;</td>
          <td class="paramname"><em>codepoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encode a single Unicode codepoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codepoint</td><td>The Unicode codepoint to encode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, a string containing the encoded Unicode codepoint. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="a4576b56e7b4b086512f02f86c19d42b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4576b56e7b4b086512f02f86c19d42b4">&#9670;&nbsp;</a></span>escape_all_codepoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<div class="memtemplate">
template&lt;char UnicodePrefix&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; StringType &gt; <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::escape_all_codepoints </td>
          <td>(</td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Escape all Unicode codepoints in a string.</p>
<p>If the Unicode codepoint is an ASCII, non-control character (i.e. codepoints in the range [U+0020, U+007E]), that character is not escaped.</p>
<p>If the Unicode codepoint is non-ASCII or a control character (i.e. codepoints in the range [U+0000, U+001F] or [U+007F, U+10FFFF]), the codepoint is encoded as follows, taking into consideration the provided Unicode prefix character: </p><pre class="fragment">1. If the Unicode codepoint is in the range [U+0000, U+001F] or [U+007F, U+FFFF],
   regardless of the prefix character, the encoding will be of the form \unnnn.
2. If the codepoint is in the range [U+10000, U+10FFFF], and the prefix character is 'u',
   the encoding will be a surrogate pair of the form \unnnn\unnnn.
3. If the codepoint is in the range [U+10000, U+10FFFF], and the prefix character is 'U',
   the encoding will of the form \Unnnnnnnn.
</pre><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnicodePrefix</td><td>The Unicode prefix character ('u' or 'U').</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to escape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, a copy of the source string with all Unicode codepoints escaped. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="a017b07c658e113e3b7bfb493b1855b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017b07c658e113e3b7bfb493b1855b2f">&#9670;&nbsp;</a></span>escape_codepoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<div class="memtemplate">
template&lt;char UnicodePrefix, typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; StringType &gt; <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::escape_codepoint </td>
          <td>(</td>
          <td class="paramtype">IteratorType &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Escape a single Unicode codepoint, starting at the character pointed to by the provided iterator. If successful, after invoking this method, that iterator will point at the first character after the Unicode codepoint in the source string.</p>
<p>If the Unicode codepoint is an ASCII, non-control character (i.e. codepoints in the range [U+0020, U+007E]), that character is not escaped.</p>
<p>If the Unicode codepoint is non-ASCII or a control character (i.e. codepoints in the range [U+0000, U+001F] or [U+007F, U+10FFFF]), the codepoint is encoded as follows, taking into consideration the provided Unicode prefix character: </p><pre class="fragment">1. If the Unicode codepoint is in the range [U+0000, U+001F] or [U+007F, U+FFFF],
   regardless of the prefix character, the encoding will be of the form \unnnn.
2. If the codepoint is in the range [U+10000, U+10FFFF], and the prefix character is 'u',
   the encoding will be a surrogate pair of the form \unnnn\unnnn.
3. If the codepoint is in the range [U+10000, U+10FFFF], and the prefix character is 'U',
   the encoding will of the form \Unnnnnnnn.
</pre><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnicodePrefix</td><td>The Unicode prefix character ('u' or 'U'). </td></tr>
    <tr><td class="paramname">IteratorType</td><td>The type of the encoded Unicode codepoint's iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Pointer to the beginning of the encoded Unicode codepoint. </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to the end of the encoded Unicode codepoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, a string containing the escaped Unicode codepoint. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="aca6f98cb3e4f612d23f9f309436499f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6f98cb3e4f612d23f9f309436499f9">&#9670;&nbsp;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<div class="memtemplate">
template&lt;typename... ParameterTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringType <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::format </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfly_1_1detail_1_1BasicFormatString.html">FormatString</a>&lt; ParameterTypes... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParameterTypes &amp;&amp;...&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Format a string with a set of format parameters, returning the formatted string. Based strongly upon: <a href="https://en.cppreference.com/w/cpp/utility/format/format">https://en.cppreference.com/w/cpp/utility/format/format</a>.</p>
<p>A format string consists of: </p><pre class="fragment">1. Any character other than "{" or "}", which are copied unchanged to the output.
2. Escape sequences "{{" and "}}", which are replaced with "{" and "}" in the output.
3. Replacement fields.
</pre><p>Replacement fields may be of the form: </p><pre class="fragment">1. An introductory "{" character.
2. An optional non-negative position.
3. An optional colon ":" following by formatting options.
4. A final "}" character.
</pre><p>For a detailed description of replacement fields see <a class="el" href="structfly_1_1detail_1_1BasicFormatSpecifier.html">fly::detail::BasicFormatSpecifier</a>.</p>
<p>This implementation differs from std::format in the following ways:</p>
<ol type="1">
<li>All standard string types are supported as format strings.</li>
<li>All standard string types are supported as format parameters, even if that type differs from the format string type. If the type differs, the format parameter is transcoded to the type of the format string.</li>
<li>Any generic type for which an operator&lt;&lt; overload is defined will be converted to a string using that overload.</li>
<li>Formatting of strong enumeration types defaults to the format of the enumeration's underlying type. However, if an overload of operator&lt;&lt; is defined, the type is treated as a generic type according to (3) above.</li>
<li>This implementation is exceptionless. Any error encountered (such as failed transcoding in (2) above) results in the format parameter that caused the error to be dropped.</li>
<li>Locale-specific form is not supported. If the option appears in the format string, it will be parsed, but will be ignored.</li>
</ol>
<p>The format string type is implicitly constructed from a C-string literal. Callers should only invoke this method accordingly: </p><pre class="fragment">format("Format {:d}", 1);
</pre><p>On compilers that support immediate functions (consteval), the format string is validated at compile time against the types of the format parameters. If the format string is invalid, a compile error with a diagnostic message will be raised. On other compilers, the error message will be returned rather than a formatted string.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ParameterTypes</td><td>Variadic format parameter types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>The string to format. </td></tr>
    <tr><td class="paramname">parameters</td><td>The variadic list of format parameters to be formatted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that has been formatted with the given format parameters. </dd></dl>

</div>
</div>
<a id="aae95f7f2e4dd207a9f42312c15dfc0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae95f7f2e4dd207a9f42312c15dfc0b2">&#9670;&nbsp;</a></span>generate_random_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringType <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::generate_random_string </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a random string of the given length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The length of the string to generate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated string. </dd></dl>

</div>
</div>
<a id="a7e50bb6745db448761589840ba8d2492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e50bb6745db448761589840ba8d2492">&#9670;&nbsp;</a></span>is_alpha()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::is_alpha </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given character is an alphabetic character as classified by the default C locale.</p>
<p>The STL's std::isalpha and std::iswalpha require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is an alphabetic character. </dd></dl>

</div>
</div>
<a id="a063bb471ab4167067a6302bac9e1a456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063bb471ab4167067a6302bac9e1a456">&#9670;&nbsp;</a></span>is_digit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::is_digit </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given character is a decimal digit character.</p>
<p>The STL's std::isdigit and std::iswdigit require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a decimal digit character. </dd></dl>

</div>
</div>
<a id="ac7d8a7ed3c089ff6403a5bb85a1947fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d8a7ed3c089ff6403a5bb85a1947fd">&#9670;&nbsp;</a></span>is_lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::is_lower </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given character is a lower-case alphabetic character as classified by the default C locale.</p>
<p>The STL's std::islower and std::iswlower require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is an alphabetic character. </dd></dl>

</div>
</div>
<a id="aacf3375a7a732d25a2c28f46abd2c2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf3375a7a732d25a2c28f46abd2c2b6">&#9670;&nbsp;</a></span>is_space()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::is_space </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given character is a whitespace character as classified by the default C locale.</p>
<p>The STL's std::isspace and std::iswspace require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a whitespace character. </dd></dl>

</div>
</div>
<a id="ac2a7f2d674c1390805e02c4e1b4af19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a7f2d674c1390805e02c4e1b4af19e">&#9670;&nbsp;</a></span>is_upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::is_upper </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given character is an upper-case alphabetic character as classified by the default C locale.</p>
<p>The STL's std::isupper and std::iswupper require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is an alphabetic character. </dd></dl>

</div>
</div>
<a id="a1c3e5bd7d7cc42418c5d888d83c6a36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3e5bd7d7cc42418c5d888d83c6a36f">&#9670;&nbsp;</a></span>is_x_digit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::is_x_digit </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given character is a hexadecimal digit character.</p>
<p>The STL's std::isxdigit and std::iswxdigit require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a hexadecimal digit character. </dd></dl>

</div>
</div>
<a id="a62209dbbae5f1faba54f5ed170c92086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62209dbbae5f1faba54f5ed170c92086">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringType <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::join </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Concatenate a list of objects with the given separator.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variadic template arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>Character to use as a separator. </td></tr>
    <tr><td class="paramname">args</td><td>The variadic list of arguments to be joined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting join of the given arguments. </dd></dl>

</div>
</div>
<a id="ad496bb598d50bcee52a560ab45621869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad496bb598d50bcee52a560ab45621869">&#9670;&nbsp;</a></span>remove_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::remove_all </td>
          <td>(</td>
          <td class="paramtype">StringType &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove all instances of a substring in a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The string container which will be modified. </td></tr>
    <tr><td class="paramname">search</td><td>The string to search for and remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6e262304fda915d1abfa76f3f31735d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e262304fda915d1abfa76f3f31735d">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::replace_all </td>
          <td>(</td>
          <td class="paramtype">StringType &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace all instances of a substring in a string with a character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The string container which will be modified. </td></tr>
    <tr><td class="paramname">search</td><td>The string to search for and replace. </td></tr>
    <tr><td class="paramname">replace</td><td>The replacement character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdcbd0e7603b9e1c0ddf9d3a17ce12d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcbd0e7603b9e1c0ddf9d3a17ce12d0">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::replace_all </td>
          <td>(</td>
          <td class="paramtype">StringType &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace all instances of a substring in a string with another string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The string container which will be modified. </td></tr>
    <tr><td class="paramname">search</td><td>The string to search for and replace. </td></tr>
    <tr><td class="paramname">replace</td><td>The replacement string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01ce84a290b7d8f062e4df728902abfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ce84a290b7d8f062e4df728902abfa">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<div class="memtemplate">
template&lt;typename T , enable_if&lt; detail::is_like_supported_string&lt; T &gt;&gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_type <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::size </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the length of any string-like value. Accepts character arrays, std::basic_string specializations, and std::basic_string_view specializations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The string-like type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string-like value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string-like value. </dd></dl>

</div>
</div>
<a id="a7574cb70c8fbc106034225c4c0b45a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7574cb70c8fbc106034225c4c0b45a25">&#9670;&nbsp;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; StringType &gt; <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::split </td>
          <td>(</td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a string into a vector of strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The string to split. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The delimiter to split the string on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the split strings. </dd></dl>

</div>
</div>
<a id="a82116d7a93abc2f5893bd478f2c25210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82116d7a93abc2f5893bd478f2c25210">&#9670;&nbsp;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; StringType &gt; <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::split </td>
          <td>(</td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a string into a vector of strings, up to a maximum size. If the max size is reached, the rest of the string is appended to the last element in the vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The string to split. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The delimiter to split the string on. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum return vector size. Zero implies unlimited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the split strings. </dd></dl>

</div>
</div>
<a id="ae7223598069892ad8f701a6397ba7659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7223598069892ad8f701a6397ba7659">&#9670;&nbsp;</a></span>to_lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::to_lower </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the given character to a lower-case alphabetic character as classified by the default C locale.</p>
<p>The STL's std:tolower and std::towlower require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted character. </dd></dl>

</div>
</div>
<a id="a1fe38a18a63ee464796607c8c187a31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe38a18a63ee464796607c8c187a31a">&#9670;&nbsp;</a></span>to_upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::to_upper </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the given character to an upper-case alphabetic character as classified by the default C locale.</p>
<p>The STL's std:toupper and std::towupper require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted character. </dd></dl>

</div>
</div>
<a id="af012575a70e73bb819748add2929fb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af012575a70e73bb819748add2929fb9f">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::trim </td>
          <td>(</td>
          <td class="paramtype">StringType &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove leading and trailing whitespace from a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The string to trim. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c1cd7927f49c82231891d5a722b739b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1cd7927f49c82231891d5a722b739b">&#9670;&nbsp;</a></span>unescape_all_codepoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; StringType &gt; <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::unescape_all_codepoints </td>
          <td>(</td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unescape all Unicode codepoints in a string.</p>
<p>Accepts escaped sequences of the following forms: </p><pre class="fragment">1. \unnnn for Unicode codepoints in the range [U+0000, U+FFFF].
2. \unnnn\unnnn surrogate pairs for Unicode codepoints in the range [U+10000, U+10FFFF].
3. \Unnnnnnnn for all Unicode codepoints.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string containing the escaped character sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, a copy of the source string with all Unicode codepoints unescaped. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="ab15fd6e9185f7bb3f1eb7e1473f86107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15fd6e9185f7bb3f1eb7e1473f86107">&#9670;&nbsp;</a></span>unescape_codepoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; StringType &gt; <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::unescape_codepoint </td>
          <td>(</td>
          <td class="paramtype">IteratorType &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unescape a single Unicode codepoint, starting at the character pointed to by provided iterator. If successful, after invoking this method, that iterator will point at the first character after the escaped sequence in the source string.</p>
<p>Accepts escaped sequences of the following forms: </p><pre class="fragment">1. \unnnn for Unicode codepoints in the range [U+0000, U+FFFF].
2. \unnnn\unnnn surrogate pairs for Unicode codepoints in the range [U+10000, U+10FFFF].
3. \Unnnnnnnn for all Unicode codepoints.
</pre><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IteratorType</td><td>The type of the escaped Unicode string's iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Pointer to the beginning of the escaped character sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to the end of the escaped character sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, a string containing the unescaped Unicode codepoint. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="adab7915d5010b7ce5508ce80d041689f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab7915d5010b7ce5508ce80d041689f">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::validate </td>
          <td>(</td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate that a string is strictly Unicode compliant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to validate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string is Unicode compliant. </dd></dl>

</div>
</div>
<a id="a7c09b4a9ef6e0bd648babb1646ce0894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c09b4a9ef6e0bd648babb1646ce0894">&#9670;&nbsp;</a></span>wildcard_match()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfly_1_1BasicString.html">fly::BasicString</a>&lt; StringType &gt;::wildcard_match </td>
          <td>(</td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if a string matches another string with wildcard expansion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source string to match against. </td></tr>
    <tr><td class="paramname">search</td><td>The wildcard string to search with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the wildcard string matches the source string. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>fly/types/string/<a class="el" href="string_8hpp_source.html">string.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>fly</b></li><li class="navelem"><a class="el" href="classfly_1_1BasicString.html">BasicString</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
