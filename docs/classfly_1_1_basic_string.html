<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libfly: fly::BasicString&lt; CharType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libfly
   &#160;<span id="projectnumber">6.2.2</span>
   </div>
   <div id="projectbrief">C++20 utility library for Linux, macOS, and Windows</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classfly_1_1_basic_string.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classfly_1_1_basic_string-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fly::BasicString&lt; CharType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="string_8hpp_source.html">string.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a458b3d76a95aeaa3322b721f214612af"><td class="memItemLeft" align="right" valign="top"><a id="a458b3d76a95aeaa3322b721f214612af"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>string_type</b> = typename traits::string_type</td></tr>
<tr class="separator:a458b3d76a95aeaa3322b721f214612af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886297cbaecad6b984128f46b2aa3c65"><td class="memItemLeft" align="right" valign="top"><a id="a886297cbaecad6b984128f46b2aa3c65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename traits::size_type</td></tr>
<tr class="separator:a886297cbaecad6b984128f46b2aa3c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5b1b0f608e2a83371a7570d891d8d3"><td class="memItemLeft" align="right" valign="top"><a id="a2b5b1b0f608e2a83371a7570d891d8d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>char_type</b> = typename traits::char_type</td></tr>
<tr class="separator:a2b5b1b0f608e2a83371a7570d891d8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abdebf5684fb8c7678eb0f38de73c24"><td class="memItemLeft" align="right" valign="top"><a id="a3abdebf5684fb8c7678eb0f38de73c24"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>view_type</b> = typename traits::view_type</td></tr>
<tr class="separator:a3abdebf5684fb8c7678eb0f38de73c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdb5c3ff7839d6c5fc7459e02aa1338"><td class="memItemLeft" align="right" valign="top"><a id="aacdb5c3ff7839d6c5fc7459e02aa1338"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>int_type</b> = typename traits::int_type</td></tr>
<tr class="separator:aacdb5c3ff7839d6c5fc7459e02aa1338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abcdfd568f5b50d9ee9225e8c637230"><td class="memItemLeft" align="right" valign="top"><a id="a5abcdfd568f5b50d9ee9225e8c637230"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>codepoint_type</b> = typename traits::codepoint_type</td></tr>
<tr class="separator:a5abcdfd568f5b50d9ee9225e8c637230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c36a8ff515d2bda24db6d4a4dcd3f2"><td class="memTemplParams" colspan="2"><a id="a32c36a8ff515d2bda24db6d4a4dcd3f2"></a>
template&lt;typename... ParameterTypes&gt; </td></tr>
<tr class="memitem:a32c36a8ff515d2bda24db6d4a4dcd3f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FormatString</b> = <a class="el" href="classfly_1_1detail_1_1_basic_format_string.html">detail::BasicFormatString</a>&lt; char_type, std::type_identity_t&lt; ParameterTypes &gt;... &gt;</td></tr>
<tr class="separator:a32c36a8ff515d2bda24db6d4a4dcd3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa6347419b73acc5aef9da7ef8029f176"><td class="memTemplParams" colspan="2"><a id="aa6347419b73acc5aef9da7ef8029f176"></a>
template&lt;StandardStringLike T&gt; </td></tr>
<tr class="memitem:aa6347419b73acc5aef9da7ef8029f176"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>size</b> (T &amp;&amp;value) -&gt; size_type</td></tr>
<tr class="separator:aa6347419b73acc5aef9da7ef8029f176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5425296b62fd92676c1bc3368eb94b13"><td class="memTemplParams" colspan="2"><a id="a5425296b62fd92676c1bc3368eb94b13"></a>
template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a5425296b62fd92676c1bc3368eb94b13"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>decode_codepoint</b> (IteratorType &amp;it, const IteratorType &amp;end) -&gt; std::optional&lt; codepoint_type &gt;</td></tr>
<tr class="separator:a5425296b62fd92676c1bc3368eb94b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63063023e45ff14fa5929d6c74d525bd"><td class="memTemplParams" colspan="2"><a id="a63063023e45ff14fa5929d6c74d525bd"></a>
template&lt;char UnicodePrefix&gt; </td></tr>
<tr class="memitem:a63063023e45ff14fa5929d6c74d525bd"><td class="memTemplItemLeft" align="right" valign="top">requires fly::UnicodePrefixCharacter&lt; UnicodePrefix &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>escape_all_codepoints</b> (view_type value) -&gt; std::optional&lt; string_type &gt;</td></tr>
<tr class="separator:a63063023e45ff14fa5929d6c74d525bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acc4e3f16b22544a04d640c6141766d"><td class="memTemplParams" colspan="2"><a id="a8acc4e3f16b22544a04d640c6141766d"></a>
template&lt;char UnicodePrefix, typename IteratorType &gt; </td></tr>
<tr class="memitem:a8acc4e3f16b22544a04d640c6141766d"><td class="memTemplItemLeft" align="right" valign="top">requires fly::UnicodePrefixCharacter&lt; UnicodePrefix &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>escape_codepoint</b> (IteratorType &amp;it, const IteratorType &amp;end) -&gt; std::optional&lt; string_type &gt;</td></tr>
<tr class="separator:a8acc4e3f16b22544a04d640c6141766d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3892c8f23e010d82879cff337aa4f75b"><td class="memTemplParams" colspan="2"><a id="a3892c8f23e010d82879cff337aa4f75b"></a>
template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a3892c8f23e010d82879cff337aa4f75b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unescape_codepoint</b> (IteratorType &amp;it, const IteratorType &amp;end) -&gt; std::optional&lt; string_type &gt;</td></tr>
<tr class="separator:a3892c8f23e010d82879cff337aa4f75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ae98e1c895857633b82985a0214bc1"><td class="memTemplParams" colspan="2"><a id="ac8ae98e1c895857633b82985a0214bc1"></a>
template&lt;typename... ParameterTypes&gt; </td></tr>
<tr class="memitem:ac8ae98e1c895857633b82985a0214bc1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>format</b> (<a class="el" href="classfly_1_1detail_1_1_basic_format_string.html">FormatString</a>&lt; ParameterTypes... &gt; &amp;&amp;fmt, ParameterTypes &amp;&amp;...parameters) -&gt; string_type</td></tr>
<tr class="separator:ac8ae98e1c895857633b82985a0214bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da6f9b3aaee7cdb57b20968d71275aa"><td class="memTemplParams" colspan="2"><a id="a7da6f9b3aaee7cdb57b20968d71275aa"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7da6f9b3aaee7cdb57b20968d71275aa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>join</b> (char_type separator, Args &amp;&amp;...args) -&gt; string_type</td></tr>
<tr class="separator:a7da6f9b3aaee7cdb57b20968d71275aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a74b3b0cb7ee30de49967ff6adf8a6460"><td class="memTemplParams" colspan="2">template&lt;StandardStringLike T&gt; </td></tr>
<tr class="memitem:a74b3b0cb7ee30de49967ff6adf8a6460"><td class="memTemplItemLeft" align="right" valign="top">static constexpr size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a74b3b0cb7ee30de49967ff6adf8a6460">size</a> (T &amp;&amp;value)</td></tr>
<tr class="separator:a74b3b0cb7ee30de49967ff6adf8a6460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9dcbee59e2f52895021158120988e6"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a7b9dcbee59e2f52895021158120988e6">is_alpha</a> (char_type ch)</td></tr>
<tr class="separator:a7b9dcbee59e2f52895021158120988e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0bc79807bbcf63c2dacfc7088b8e82"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a3b0bc79807bbcf63c2dacfc7088b8e82">is_upper</a> (char_type ch)</td></tr>
<tr class="separator:a3b0bc79807bbcf63c2dacfc7088b8e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae336d7abb3e980acc675b4dadf8d064a"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#ae336d7abb3e980acc675b4dadf8d064a">is_lower</a> (char_type ch)</td></tr>
<tr class="separator:ae336d7abb3e980acc675b4dadf8d064a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd362bfc2655b806fbc43eb0a0e224d1"><td class="memItemLeft" align="right" valign="top">static constexpr char_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#abd362bfc2655b806fbc43eb0a0e224d1">to_upper</a> (char_type ch)</td></tr>
<tr class="separator:abd362bfc2655b806fbc43eb0a0e224d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8affa6281a09010a3d70cf85e09ca151"><td class="memItemLeft" align="right" valign="top">static constexpr char_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a8affa6281a09010a3d70cf85e09ca151">to_lower</a> (char_type ch)</td></tr>
<tr class="separator:a8affa6281a09010a3d70cf85e09ca151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df3b30785d6a1c17d4fa6268b3984dd"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a8df3b30785d6a1c17d4fa6268b3984dd">is_digit</a> (char_type ch)</td></tr>
<tr class="separator:a8df3b30785d6a1c17d4fa6268b3984dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbaa9bf55cfb04d6858d697d11ba9dc2"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#afbaa9bf55cfb04d6858d697d11ba9dc2">is_x_digit</a> (char_type ch)</td></tr>
<tr class="separator:afbaa9bf55cfb04d6858d697d11ba9dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaaceed4066e5ada1a834a78a02993b"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a6eaaceed4066e5ada1a834a78a02993b">is_space</a> (char_type ch)</td></tr>
<tr class="separator:a6eaaceed4066e5ada1a834a78a02993b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4596b45423b5242f32a5a47c4161e34"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; string_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#ad4596b45423b5242f32a5a47c4161e34">split</a> (view_type input, char_type delimiter)</td></tr>
<tr class="separator:ad4596b45423b5242f32a5a47c4161e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222e8c0e173f63f4d1a1edb266d86bb8"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; string_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a222e8c0e173f63f4d1a1edb266d86bb8">split</a> (view_type input, char_type delimiter, size_type count)</td></tr>
<tr class="separator:a222e8c0e173f63f4d1a1edb266d86bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96739670960f3963064f5e76d8606688"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a96739670960f3963064f5e76d8606688">trim</a> (string_type &amp;target)</td></tr>
<tr class="separator:a96739670960f3963064f5e76d8606688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524ce1d4cc3d62efcd6a26046fb74800"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a524ce1d4cc3d62efcd6a26046fb74800">replace_all</a> (string_type &amp;target, view_type search, char_type replace)</td></tr>
<tr class="separator:a524ce1d4cc3d62efcd6a26046fb74800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287001989634a14b131bfddecb65c263"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a287001989634a14b131bfddecb65c263">replace_all</a> (string_type &amp;target, view_type search, view_type replace)</td></tr>
<tr class="separator:a287001989634a14b131bfddecb65c263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f774aee270f844b2fe75ec2feed7d6a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a1f774aee270f844b2fe75ec2feed7d6a">remove_all</a> (string_type &amp;target, view_type search)</td></tr>
<tr class="separator:a1f774aee270f844b2fe75ec2feed7d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0631f046cf93b4dd352334eb281467"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#aef0631f046cf93b4dd352334eb281467">wildcard_match</a> (view_type source, view_type search)</td></tr>
<tr class="separator:aef0631f046cf93b4dd352334eb281467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa6f9ccfa3d8f00b0d765793d6cd6a8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a8fa6f9ccfa3d8f00b0d765793d6cd6a8">validate</a> (view_type value)</td></tr>
<tr class="separator:a8fa6f9ccfa3d8f00b0d765793d6cd6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba96a31f302976ba37a4b86d0350bf4"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a9ba96a31f302976ba37a4b86d0350bf4"><td class="memTemplItemLeft" align="right" valign="top">static std::optional&lt; codepoint_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a9ba96a31f302976ba37a4b86d0350bf4">decode_codepoint</a> (IteratorType &amp;it, const IteratorType &amp;end)</td></tr>
<tr class="separator:a9ba96a31f302976ba37a4b86d0350bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ddbf0e5de084910eaad87c45898224"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; string_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a84ddbf0e5de084910eaad87c45898224">encode_codepoint</a> (codepoint_type codepoint)</td></tr>
<tr class="separator:a84ddbf0e5de084910eaad87c45898224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce41ac7d3b5217724b4b0f7a60e2560"><td class="memTemplParams" colspan="2">template&lt;char UnicodePrefix = 'U'&gt; </td></tr>
<tr class="memitem:a6ce41ac7d3b5217724b4b0f7a60e2560"><td class="memTemplItemLeft" align="right" valign="top">requires static fly::UnicodePrefixCharacter&lt; UnicodePrefix &gt; std::optional&lt; string_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a6ce41ac7d3b5217724b4b0f7a60e2560">escape_all_codepoints</a> (view_type value)</td></tr>
<tr class="separator:a6ce41ac7d3b5217724b4b0f7a60e2560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b96a50e6324eebc3221a8359ea26a6"><td class="memTemplParams" colspan="2">template&lt;char UnicodePrefix = 'U', typename IteratorType &gt; </td></tr>
<tr class="memitem:ae0b96a50e6324eebc3221a8359ea26a6"><td class="memTemplItemLeft" align="right" valign="top">requires static fly::UnicodePrefixCharacter&lt; UnicodePrefix &gt; std::optional&lt; string_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#ae0b96a50e6324eebc3221a8359ea26a6">escape_codepoint</a> (IteratorType &amp;it, const IteratorType &amp;end)</td></tr>
<tr class="separator:ae0b96a50e6324eebc3221a8359ea26a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b35cb8a4c26be5ba0a52feb5374ad77"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; string_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a7b35cb8a4c26be5ba0a52feb5374ad77">unescape_all_codepoints</a> (view_type value)</td></tr>
<tr class="separator:a7b35cb8a4c26be5ba0a52feb5374ad77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe0f27abdcf915410e02ba193db498e"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a4fe0f27abdcf915410e02ba193db498e"><td class="memTemplItemLeft" align="right" valign="top">static std::optional&lt; string_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a4fe0f27abdcf915410e02ba193db498e">unescape_codepoint</a> (IteratorType &amp;it, const IteratorType &amp;end)</td></tr>
<tr class="separator:a4fe0f27abdcf915410e02ba193db498e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827ace4ffc68fa90332ced117d8f458b"><td class="memItemLeft" align="right" valign="top">static string_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a827ace4ffc68fa90332ced117d8f458b">generate_random_string</a> (size_type length)</td></tr>
<tr class="separator:a827ace4ffc68fa90332ced117d8f458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b604da44c9309c4737739e8063ba81"><td class="memTemplParams" colspan="2">template&lt;typename... ParameterTypes&gt; </td></tr>
<tr class="memitem:a30b604da44c9309c4737739e8063ba81"><td class="memTemplItemLeft" align="right" valign="top">static string_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a30b604da44c9309c4737739e8063ba81">format</a> (<a class="el" href="classfly_1_1detail_1_1_basic_format_string.html">FormatString</a>&lt; ParameterTypes... &gt; &amp;&amp;fmt, ParameterTypes &amp;&amp;...parameters)</td></tr>
<tr class="separator:a30b604da44c9309c4737739e8063ba81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bdcbd266a8e41db419f0884da2d011"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename... ParameterTypes&gt; </td></tr>
<tr class="memitem:aa9bdcbd266a8e41db419f0884da2d011"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#aa9bdcbd266a8e41db419f0884da2d011">format_to</a> (OutputIterator output, <a class="el" href="classfly_1_1detail_1_1_basic_format_string.html">FormatString</a>&lt; ParameterTypes... &gt; &amp;&amp;fmt, ParameterTypes &amp;&amp;...parameters)</td></tr>
<tr class="separator:aa9bdcbd266a8e41db419f0884da2d011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace38381ce149a0934c2072387f2a2873"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ace38381ce149a0934c2072387f2a2873"><td class="memTemplItemLeft" align="right" valign="top">static string_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#ace38381ce149a0934c2072387f2a2873">join</a> (char_type separator, Args &amp;&amp;...args)</td></tr>
<tr class="separator:ace38381ce149a0934c2072387f2a2873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c1bbe6fd507f45133157d82250f4a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51c1bbe6fd507f45133157d82250f4a3"><td class="memTemplItemLeft" align="right" valign="top">static std::optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1_basic_string.html#a51c1bbe6fd507f45133157d82250f4a3">convert</a> (const string_type &amp;value)</td></tr>
<tr class="separator:a51c1bbe6fd507f45133157d82250f4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;StandardCharacter CharType&gt;<br />
class fly::BasicString&lt; CharType &gt;</h3>

<p>Static class to provide string utilities not provided by the STL.</p>
<dl class="section author"><dt>Author</dt><dd>Timothy Flynn (<a href="#" onclick="location.href='mai'+'lto:'+'trf'+'ly'+'nn8'+'9@'+'pm.'+'me'; return false;">trfly<span style="display: none;">.nosp@m.</span>nn89<span style="display: none;">.nosp@m.</span>@pm.m<span style="display: none;">.nosp@m.</span>e</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>March 21, 2019 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a51c1bbe6fd507f45133157d82250f4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c1bbe6fd507f45133157d82250f4a3">&#9670;&nbsp;</a></span>convert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::convert </td>
          <td>(</td>
          <td class="paramtype">const string_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a string to another type. The other type may be a string with a different Unicode encoding or a plain-old-data type, e.g. int or bool.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The desired type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, the string coverted to the specified type. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="a9ba96a31f302976ba37a4b86d0350bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba96a31f302976ba37a4b86d0350bf4">&#9670;&nbsp;</a></span>decode_codepoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;codepoint_type&gt; <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::decode_codepoint </td>
          <td>(</td>
          <td class="paramtype">IteratorType &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decode a single Unicode codepoint, starting at the character pointed to by the provided iterator. If successful, after invoking this method, that iterator will point at the first character after the Unicode codepoint in the source string.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IteratorType</td><td>The type of the encoded Unicode codepoint's iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Pointer to the beginning of the encoded Unicode codepoint. </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to the end of the encoded Unicode codepoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, the decoded Unicode codepoint. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="a84ddbf0e5de084910eaad87c45898224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ddbf0e5de084910eaad87c45898224">&#9670;&nbsp;</a></span>encode_codepoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::encode_codepoint </td>
          <td>(</td>
          <td class="paramtype">codepoint_type&#160;</td>
          <td class="paramname"><em>codepoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encode a single Unicode codepoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codepoint</td><td>The Unicode codepoint to encode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, a string containing the encoded Unicode codepoint. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="a6ce41ac7d3b5217724b4b0f7a60e2560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce41ac7d3b5217724b4b0f7a60e2560">&#9670;&nbsp;</a></span>escape_all_codepoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<div class="memtemplate">
template&lt;char UnicodePrefix = 'U'&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires static fly::UnicodePrefixCharacter&lt;UnicodePrefix&gt; std::optional&lt;string_type&gt; <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::escape_all_codepoints </td>
          <td>(</td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Escape all Unicode codepoints in a string.</p>
<p>If the Unicode codepoint is an ASCII, non-control character (i.e. codepoints in the range [U+0020, U+007E]), that character is not escaped.</p>
<p>If the Unicode codepoint is non-ASCII or a control character (i.e. codepoints in the range [U+0000, U+001F] or [U+007F, U+10FFFF]), the codepoint is encoded as follows, taking into consideration the provided Unicode prefix character: </p><pre class="fragment">1. If the Unicode codepoint is in the range [U+0000, U+001F] or [U+007F, U+FFFF],
   regardless of the prefix character, the encoding will be of the form \unnnn.
2. If the codepoint is in the range [U+10000, U+10FFFF], and the prefix character is 'u',
   the encoding will be a surrogate pair of the form \unnnn\unnnn.
3. If the codepoint is in the range [U+10000, U+10FFFF], and the prefix character is 'U',
   the encoding will of the form \Unnnnnnnn.
</pre> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnicodePrefix</td><td>The Unicode prefix character ('u' or 'U').</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to escape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, a copy of the source string with all Unicode codepoints escaped. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="ae0b96a50e6324eebc3221a8359ea26a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b96a50e6324eebc3221a8359ea26a6">&#9670;&nbsp;</a></span>escape_codepoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<div class="memtemplate">
template&lt;char UnicodePrefix = 'U', typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires static fly::UnicodePrefixCharacter&lt;UnicodePrefix&gt; std::optional&lt;string_type&gt; <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::escape_codepoint </td>
          <td>(</td>
          <td class="paramtype">IteratorType &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Escape a single Unicode codepoint, starting at the character pointed to by the provided iterator. If successful, after invoking this method, that iterator will point at the first character after the Unicode codepoint in the source string.</p>
<p>If the Unicode codepoint is an ASCII, non-control character (i.e. codepoints in the range [U+0020, U+007E]), that character is not escaped.</p>
<p>If the Unicode codepoint is non-ASCII or a control character (i.e. codepoints in the range [U+0000, U+001F] or [U+007F, U+10FFFF]), the codepoint is encoded as follows, taking into consideration the provided Unicode prefix character: </p><pre class="fragment">1. If the Unicode codepoint is in the range [U+0000, U+001F] or [U+007F, U+FFFF],
   regardless of the prefix character, the encoding will be of the form \unnnn.
2. If the codepoint is in the range [U+10000, U+10FFFF], and the prefix character is 'u',
   the encoding will be a surrogate pair of the form \unnnn\unnnn.
3. If the codepoint is in the range [U+10000, U+10FFFF], and the prefix character is 'U',
   the encoding will of the form \Unnnnnnnn.
</pre> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnicodePrefix</td><td>The Unicode prefix character ('u' or 'U'). </td></tr>
    <tr><td class="paramname">IteratorType</td><td>The type of the encoded Unicode codepoint's iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Pointer to the beginning of the encoded Unicode codepoint. </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to the end of the encoded Unicode codepoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, a string containing the escaped Unicode codepoint. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="a30b604da44c9309c4737739e8063ba81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b604da44c9309c4737739e8063ba81">&#9670;&nbsp;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<div class="memtemplate">
template&lt;typename... ParameterTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string_type <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::format </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfly_1_1detail_1_1_basic_format_string.html">FormatString</a>&lt; ParameterTypes... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParameterTypes &amp;&amp;...&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Format a string with a set of format parameters, returning the formatted string. Based strongly upon: <a href="https://en.cppreference.com/w/cpp/utility/format/format">https://en.cppreference.com/w/cpp/utility/format/format</a>.</p>
<p>A format string consists of: </p><pre class="fragment">1. Any character other than "{" or "}", which are copied unchanged to the output.
2. Escape sequences "{{" and "}}", which are replaced with "{" and "}" in the output.
3. Replacement fields.
</pre><p> Replacement fields may be of the form: </p><pre class="fragment">1. An introductory "{" character.
2. An optional non-negative position.
3. An optional colon ":" following by formatting options.
4. A final "}" character.
</pre><p> For a detailed description of replacement fields, see <a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html">fly::detail::BasicFormatSpecifier</a>.</p>
<p>This implementation differs from std::format in the following ways:</p>
<ol type="1">
<li>All standard string types are supported as format strings.</li>
<li>All standard string types are supported as format parameters, even if that type differs from the format string type. If the type differs, the format parameter is transcoded to the type of the format string.</li>
<li>This implementation is exceptionless. Any error encountered (such as failed transcoding in (2) above) results in the format parameter that caused the error to be dropped.</li>
<li>Locale-specific form is not supported. If the option appears in the format string, it will be parsed, but will be ignored.</li>
</ol>
<p>The format string type is implicitly constructed from a C-string literal. Callers should only invoke this method accordingly: </p><pre class="fragment">fly::String::format("Format {:d}", 1);
</pre><p> On compilers that support immediate functions (consteval), the format string is validated at compile time against the types of the format parameters. If the format string is invalid, a compile error with a diagnostic message will be raised. On other compilers, the error message will be returned rather than a formatted string.</p>
<p>Replacement fields for user-defined types are parsed at runtime. To format a user-defined type, a <a class="el" href="structfly_1_1_formatter.html">fly::Formatter</a> specialization must be defined, analagous to std::formatter. The specialization may extend a standard <a class="el" href="structfly_1_1_formatter.html">fly::Formatter</a>, for example: </p><pre class="fragment">template &lt;typename CharType&gt;
struct fly::Formatter&lt;MyType, CharType&gt; : public fly::Formatter&lt;int, CharType&gt;
{
    template &lt;typename FormatContext&gt;
    void format(const MyType &amp;value, FormatContext &amp;context)
    {
        fly::Formatter&lt;int, CharType&gt;::format(value.as_int(), context);
    }
};
</pre><p> Or, the formatter may be defined without without inheritence: </p><pre class="fragment">template &lt;typename CharType&gt;
struct fly::Formatter&lt;MyType, CharType&gt;
{
    bool m_option {false};

    template &lt;typename FormatParseContext&gt;
    constexpr void parse(FormatParseContext &amp;context)
    {
        if (context.lexer().consume_if(FLY_CHR(CharType, 'o')))
        {
            m_option = true;
        }
        if (!context.lexer().consume_if(FLY_CHR(CharType, '}')))
        {
            context.on_error("UserDefinedTypeWithParser error!");
        }
    }

    template &lt;typename FormatContext&gt;
    void format(const MyType &amp;value, FormatContext &amp;context)
    {
        fly::BasicString&lt;CharType&gt;::format_to(context.out(), "{}", value.as_int());
    }
};
</pre><p> The |parse| method is optional. If defined, it is provided a BasicFormatParseContext which contains a lexer that may be used to parse the format string. The position of the lexer will be one of the following within the replacement field: </p><pre class="fragment">1. The position immediately after the colon, if there is one.
2. Otherwise, the position immediately after the format parameter index, if there is one.
3. Otherwise, the position immeidately after the opening brace.
</pre><p> The |parse| method is expected to consume up to and including the closing "}" character. It must be declared constexpr, as it will be invoked at compile time to validate the replacement field. The parser may indicate any parsing errors through the parsing context; if an error occurs, the error is handled the same as any standard replacement field (see above). Even though the parser is invoked at compile time, the result of user-defined parsing cannot be stored generically. Thus, parsing is invoked again at runtime immediately before |format|.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ParameterTypes</td><td>Variadic format parameter types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>The string to format. </td></tr>
    <tr><td class="paramname">parameters</td><td>The variadic list of format parameters to be formatted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that has been formatted with the given format parameters. </dd></dl>

</div>
</div>
<a id="aa9bdcbd266a8e41db419f0884da2d011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9bdcbd266a8e41db419f0884da2d011">&#9670;&nbsp;</a></span>format_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<div class="memtemplate">
template&lt;typename OutputIterator , typename... ParameterTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::format_to </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfly_1_1detail_1_1_basic_format_string.html">FormatString</a>&lt; ParameterTypes... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParameterTypes &amp;&amp;...&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Format a string with a set of format parameters to an existing output iterator. Based strongly upon: <a href="https://en.cppreference.com/w/cpp/utility/format/format">https://en.cppreference.com/w/cpp/utility/format/format</a>.</p>
<p>For a detailed description of string formatting, see <a class="el" href="classfly_1_1_basic_string.html#a30b604da44c9309c4737739e8063ba81">fly::BasicString::format</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputIterator</td><td>The type of the output iterator. </td></tr>
    <tr><td class="paramname">ParameterTypes</td><td>Variadic format parameter types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The output iterator to write to. </td></tr>
    <tr><td class="paramname">fmt</td><td>The string to format. </td></tr>
    <tr><td class="paramname">parameters</td><td>The variadic list of format parameters to be formatted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that has been formatted with the given format parameters. </dd></dl>

</div>
</div>
<a id="a827ace4ffc68fa90332ced117d8f458b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827ace4ffc68fa90332ced117d8f458b">&#9670;&nbsp;</a></span>generate_random_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::generate_random_string </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a random string of the given length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The length of the string to generate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated string. </dd></dl>

</div>
</div>
<a id="a7b9dcbee59e2f52895021158120988e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9dcbee59e2f52895021158120988e6">&#9670;&nbsp;</a></span>is_alpha()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::is_alpha </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given character is an alphabetic character as classified by the default C locale.</p>
<p>The STL's std::isalpha and std::iswalpha require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is an alphabetic character. </dd></dl>

</div>
</div>
<a id="a8df3b30785d6a1c17d4fa6268b3984dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df3b30785d6a1c17d4fa6268b3984dd">&#9670;&nbsp;</a></span>is_digit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::is_digit </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given character is a decimal digit character.</p>
<p>The STL's std::isdigit and std::iswdigit require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a decimal digit character. </dd></dl>

</div>
</div>
<a id="ae336d7abb3e980acc675b4dadf8d064a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae336d7abb3e980acc675b4dadf8d064a">&#9670;&nbsp;</a></span>is_lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::is_lower </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given character is a lower-case alphabetic character as classified by the default C locale.</p>
<p>The STL's std::islower and std::iswlower require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is an alphabetic character. </dd></dl>

</div>
</div>
<a id="a6eaaceed4066e5ada1a834a78a02993b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eaaceed4066e5ada1a834a78a02993b">&#9670;&nbsp;</a></span>is_space()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::is_space </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given character is a whitespace character as classified by the default C locale.</p>
<p>The STL's std::isspace and std::iswspace require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a whitespace character. </dd></dl>

</div>
</div>
<a id="a3b0bc79807bbcf63c2dacfc7088b8e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0bc79807bbcf63c2dacfc7088b8e82">&#9670;&nbsp;</a></span>is_upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::is_upper </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given character is an upper-case alphabetic character as classified by the default C locale.</p>
<p>The STL's std::isupper and std::iswupper require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is an alphabetic character. </dd></dl>

</div>
</div>
<a id="afbaa9bf55cfb04d6858d697d11ba9dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbaa9bf55cfb04d6858d697d11ba9dc2">&#9670;&nbsp;</a></span>is_x_digit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::is_x_digit </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given character is a hexadecimal digit character.</p>
<p>The STL's std::isxdigit and std::iswxdigit require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a hexadecimal digit character. </dd></dl>

</div>
</div>
<a id="ace38381ce149a0934c2072387f2a2873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace38381ce149a0934c2072387f2a2873">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static string_type <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::join </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Concatenate a list of objects with the given separator.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variadic template arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>Character to use as a separator. </td></tr>
    <tr><td class="paramname">args</td><td>The variadic list of arguments to be joined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting join of the given arguments. </dd></dl>

</div>
</div>
<a id="a1f774aee270f844b2fe75ec2feed7d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f774aee270f844b2fe75ec2feed7d6a">&#9670;&nbsp;</a></span>remove_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::remove_all </td>
          <td>(</td>
          <td class="paramtype">string_type &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove all instances of a substring in a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The string container which will be modified. </td></tr>
    <tr><td class="paramname">search</td><td>The string to search for and remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a524ce1d4cc3d62efcd6a26046fb74800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524ce1d4cc3d62efcd6a26046fb74800">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::replace_all </td>
          <td>(</td>
          <td class="paramtype">string_type &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace all instances of a substring in a string with a character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The string container which will be modified. </td></tr>
    <tr><td class="paramname">search</td><td>The string to search for and replace. </td></tr>
    <tr><td class="paramname">replace</td><td>The replacement character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a287001989634a14b131bfddecb65c263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287001989634a14b131bfddecb65c263">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::replace_all </td>
          <td>(</td>
          <td class="paramtype">string_type &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace all instances of a substring in a string with another string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The string container which will be modified. </td></tr>
    <tr><td class="paramname">search</td><td>The string to search for and replace. </td></tr>
    <tr><td class="paramname">replace</td><td>The replacement string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74b3b0cb7ee30de49967ff6adf8a6460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b3b0cb7ee30de49967ff6adf8a6460">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<div class="memtemplate">
template&lt;StandardStringLike T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_type <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::size </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the length of any string-like value. Accepts character arrays, std::basic_string specializations, and std::basic_string_view specializations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The string-like type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string-like value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string-like value. </dd></dl>

</div>
</div>
<a id="ad4596b45423b5242f32a5a47c4161e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4596b45423b5242f32a5a47c4161e34">&#9670;&nbsp;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::split </td>
          <td>(</td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a string into a vector of strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The string to split. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The delimiter to split the string on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the split strings. </dd></dl>

</div>
</div>
<a id="a222e8c0e173f63f4d1a1edb266d86bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222e8c0e173f63f4d1a1edb266d86bb8">&#9670;&nbsp;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::split </td>
          <td>(</td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a string into a vector of strings, up to a maximum size. If the max size is reached, the rest of the string is appended to the last element in the vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The string to split. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The delimiter to split the string on. </td></tr>
    <tr><td class="paramname">count</td><td>The maximum return vector size. Zero implies unlimited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the split strings. </dd></dl>

</div>
</div>
<a id="a8affa6281a09010a3d70cf85e09ca151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8affa6281a09010a3d70cf85e09ca151">&#9670;&nbsp;</a></span>to_lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::to_lower </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the given character to a lower-case alphabetic character as classified by the default C locale.</p>
<p>The STL's std:tolower and std::towlower require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted character. </dd></dl>

</div>
</div>
<a id="abd362bfc2655b806fbc43eb0a0e224d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd362bfc2655b806fbc43eb0a0e224d1">&#9670;&nbsp;</a></span>to_upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::to_upper </td>
          <td>(</td>
          <td class="paramtype">char_type&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the given character to an upper-case alphabetic character as classified by the default C locale.</p>
<p>The STL's std:toupper and std::towupper require that the provided character fits into an unsigned char and unsigned wchar_t, respectively. Other values result in undefined behavior. This method has no such restriction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted character. </dd></dl>

</div>
</div>
<a id="a96739670960f3963064f5e76d8606688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96739670960f3963064f5e76d8606688">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::trim </td>
          <td>(</td>
          <td class="paramtype">string_type &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove leading and trailing whitespace from a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The string to trim. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b35cb8a4c26be5ba0a52feb5374ad77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b35cb8a4c26be5ba0a52feb5374ad77">&#9670;&nbsp;</a></span>unescape_all_codepoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::unescape_all_codepoints </td>
          <td>(</td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unescape all Unicode codepoints in a string.</p>
<p>Accepts escaped sequences of the following forms: </p><pre class="fragment">1. \unnnn for Unicode codepoints in the range [U+0000, U+FFFF].
2. \unnnn\unnnn surrogate pairs for Unicode codepoints in the range [U+10000, U+10FFFF].
3. \Unnnnnnnn for all Unicode codepoints.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string containing the escaped character sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, a copy of the source string with all Unicode codepoints unescaped. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="a4fe0f27abdcf915410e02ba193db498e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe0f27abdcf915410e02ba193db498e">&#9670;&nbsp;</a></span>unescape_codepoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;string_type&gt; <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::unescape_codepoint </td>
          <td>(</td>
          <td class="paramtype">IteratorType &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorType &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unescape a single Unicode codepoint, starting at the character pointed to by provided iterator. If successful, after invoking this method, that iterator will point at the first character after the escaped sequence in the source string.</p>
<p>Accepts escaped sequences of the following forms: </p><pre class="fragment">1. \unnnn for Unicode codepoints in the range [U+0000, U+FFFF].
2. \unnnn\unnnn surrogate pairs for Unicode codepoints in the range [U+10000, U+10FFFF].
3. \Unnnnnnnn for all Unicode codepoints.
</pre> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IteratorType</td><td>The type of the escaped Unicode string's iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Pointer to the beginning of the escaped character sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to the end of the escaped character sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, a string containing the unescaped Unicode codepoint. Otherwise, an uninitialized value. </dd></dl>

</div>
</div>
<a id="a8fa6f9ccfa3d8f00b0d765793d6cd6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa6f9ccfa3d8f00b0d765793d6cd6a8">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::validate </td>
          <td>(</td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate that a string is strictly Unicode compliant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string to validate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the string is Unicode compliant. </dd></dl>

</div>
</div>
<a id="aef0631f046cf93b4dd352334eb281467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0631f046cf93b4dd352334eb281467">&#9670;&nbsp;</a></span>wildcard_match()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StandardCharacter CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfly_1_1_basic_string.html">fly::BasicString</a>&lt; CharType &gt;::wildcard_match </td>
          <td>(</td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">view_type&#160;</td>
          <td class="paramname"><em>search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if a string matches another string with wildcard expansion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source string to match against. </td></tr>
    <tr><td class="paramname">search</td><td>The wildcard string to search with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the wildcard string matches the source string. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>fly/types/string/<a class="el" href="string_8hpp_source.html">string.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>fly</b></li><li class="navelem"><a class="el" href="classfly_1_1_basic_string.html">BasicString</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
