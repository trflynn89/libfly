<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libfly: fly::detail::BasicFormatSpecifier&lt; CharType &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libfly
   &#160;<span id="projectnumber">5.0.0</span>
   </div>
   <div id="projectbrief">C++20 utility library for Linux, macOS, and Windows</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structfly_1_1detail_1_1_basic_format_specifier.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structfly_1_1detail_1_1_basic_format_specifier-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fly::detail::BasicFormatSpecifier&lt; CharType &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="format__specifier_8hpp_source.html">format_specifier.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0fde353ec2930b1783438ba8ef237427"><td class="memItemLeft" align="right" valign="top"><a id="a0fde353ec2930b1783438ba8ef237427"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>Alignment</b> : std::uint8_t { <b>Default</b>
, <b>Left</b>
, <b>Right</b>
, <b>Center</b>
 }</td></tr>
<tr class="separator:a0fde353ec2930b1783438ba8ef237427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629932644c296715d40c1c848d99679e"><td class="memItemLeft" align="right" valign="top"><a id="a629932644c296715d40c1c848d99679e"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>Sign</b> : std::uint8_t { <b>Default</b>
, <b>Always</b>
, <b>NegativeOnly</b>
, <b>NegativeOnlyWithPositivePadding</b>
 }</td></tr>
<tr class="separator:a629932644c296715d40c1c848d99679e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e8436252ced6cbc325b5eb4651e71b"><td class="memItemLeft" align="right" valign="top"><a id="a03e8436252ced6cbc325b5eb4651e71b"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>Type</b> : std::uint8_t { <br />
&#160;&#160;<b>None</b> = 20
, <b>Character</b> = 21
, <b>String</b> = 22
, <b>Pointer</b> = 23
, <br />
&#160;&#160;<b>Binary</b> = 2
, <b>Octal</b> = 8
, <b>Decimal</b> = 10
, <b>Hex</b> = 16
, <br />
&#160;&#160;<b>HexFloat</b> = 24
, <b>Scientific</b> = 25
, <b>Fixed</b> = 26
, <b>General</b> = 27
<br />
 }</td></tr>
<tr class="separator:a03e8436252ced6cbc325b5eb4651e71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42ad73ddad3a726a6c6658aa06a1e89"><td class="memItemLeft" align="right" valign="top"><a id="ad42ad73ddad3a726a6c6658aa06a1e89"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>Case</b> : std::uint8_t { <b>Lower</b>
, <b>Upper</b>
 }</td></tr>
<tr class="separator:ad42ad73ddad3a726a6c6658aa06a1e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a16cf0f31ae20f7918b3fbf217c8fcaa4"><td class="memItemLeft" align="right" valign="top"><a id="a16cf0f31ae20f7918b3fbf217c8fcaa4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BasicFormatSpecifier</b> (<a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html">BasicFormatSpecifier</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a16cf0f31ae20f7918b3fbf217c8fcaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5654332677842e85d68dc199fc57981a"><td class="memItemLeft" align="right" valign="top"><a id="a5654332677842e85d68dc199fc57981a"></a>
<a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html">BasicFormatSpecifier</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html">BasicFormatSpecifier</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a5654332677842e85d68dc199fc57981a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891890010eb57055aa81ea26799c4778"><td class="memTemplParams" colspan="2">template&lt;typename FormatString &gt; </td></tr>
<tr class="memitem:a891890010eb57055aa81ea26799c4778"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html#a891890010eb57055aa81ea26799c4778">parse</a> (FormatString &amp;format, typename FormatString::ParameterType parameter_type)</td></tr>
<tr class="separator:a891890010eb57055aa81ea26799c4778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3639ff921d74b84fa1cd147cfb4b55"><td class="memTemplParams" colspan="2">template&lt;typename FormatString &gt; </td></tr>
<tr class="memitem:ade3639ff921d74b84fa1cd147cfb4b55"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html#ade3639ff921d74b84fa1cd147cfb4b55">infer_type</a> (typename FormatString::ParameterType parameter_type)</td></tr>
<tr class="separator:ade3639ff921d74b84fa1cd147cfb4b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f28faad248b9614607686a088e3a9ba"><td class="memTemplParams" colspan="2">template&lt;typename FormatContext &gt; </td></tr>
<tr class="memitem:a7f28faad248b9614607686a088e3a9ba"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html#a7f28faad248b9614607686a088e3a9ba">width</a> (FormatContext &amp;context, std::size_t fallback) const</td></tr>
<tr class="separator:a7f28faad248b9614607686a088e3a9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5603b73b48db558ed07cd728143950af"><td class="memTemplParams" colspan="2">template&lt;typename FormatContext &gt; </td></tr>
<tr class="memitem:a5603b73b48db558ed07cd728143950af"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html#a5603b73b48db558ed07cd728143950af">precision</a> (FormatContext &amp;context, std::size_t fallback) const</td></tr>
<tr class="separator:a5603b73b48db558ed07cd728143950af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afb667466317c5620f563cbe0d5505f76"><td class="memItemLeft" align="right" valign="top"><a id="afb667466317c5620f563cbe0d5505f76"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_position</b> {0}</td></tr>
<tr class="separator:afb667466317c5620f563cbe0d5505f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c93f74769b042473ac34da086835a6c"><td class="memItemLeft" align="right" valign="top"><a id="a8c93f74769b042473ac34da086835a6c"></a>
std::optional&lt; CharType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_fill</b> {std::nullopt}</td></tr>
<tr class="separator:a8c93f74769b042473ac34da086835a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75f2265edbded5533cf1fbd6565fb06"><td class="memItemLeft" align="right" valign="top"><a id="ac75f2265edbded5533cf1fbd6565fb06"></a>
Alignment&#160;</td><td class="memItemRight" valign="bottom"><b>m_alignment</b> {Alignment::Default}</td></tr>
<tr class="separator:ac75f2265edbded5533cf1fbd6565fb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae085e15903f43cd7e85e94e5ab0c8e72"><td class="memItemLeft" align="right" valign="top"><a id="ae085e15903f43cd7e85e94e5ab0c8e72"></a>
Sign&#160;</td><td class="memItemRight" valign="bottom"><b>m_sign</b> {Sign::Default}</td></tr>
<tr class="separator:ae085e15903f43cd7e85e94e5ab0c8e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b06ee5152facd37ea7940bb63e3f227"><td class="memItemLeft" align="right" valign="top"><a id="a1b06ee5152facd37ea7940bb63e3f227"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_alternate_form</b> {false}</td></tr>
<tr class="separator:a1b06ee5152facd37ea7940bb63e3f227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8473a671b7fb05a3f387af1368cf7c81"><td class="memItemLeft" align="right" valign="top"><a id="a8473a671b7fb05a3f387af1368cf7c81"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_zero_padding</b> {false}</td></tr>
<tr class="separator:a8473a671b7fb05a3f387af1368cf7c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4b1155c9aaf1075e7dc3845f7f3caf"><td class="memItemLeft" align="right" valign="top"><a id="a8c4b1155c9aaf1075e7dc3845f7f3caf"></a>
std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_width</b> {std::nullopt}</td></tr>
<tr class="separator:a8c4b1155c9aaf1075e7dc3845f7f3caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d62c03c8a68564a159c7dcdfb7b043e"><td class="memItemLeft" align="right" valign="top"><a id="a5d62c03c8a68564a159c7dcdfb7b043e"></a>
std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_width_position</b> {std::nullopt}</td></tr>
<tr class="separator:a5d62c03c8a68564a159c7dcdfb7b043e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5d5c34833c49056bcbf5bff8108789"><td class="memItemLeft" align="right" valign="top"><a id="a2c5d5c34833c49056bcbf5bff8108789"></a>
std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_precision</b> {std::nullopt}</td></tr>
<tr class="separator:a2c5d5c34833c49056bcbf5bff8108789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84489d38e95aedf1232b4a17ddd4ed8"><td class="memItemLeft" align="right" valign="top"><a id="ae84489d38e95aedf1232b4a17ddd4ed8"></a>
std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_precision_position</b> {std::nullopt}</td></tr>
<tr class="separator:ae84489d38e95aedf1232b4a17ddd4ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fab2e3c5438ec2eb956668a2448d3ff"><td class="memItemLeft" align="right" valign="top"><a id="a3fab2e3c5438ec2eb956668a2448d3ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_locale_specific_form</b> {false}</td></tr>
<tr class="separator:a3fab2e3c5438ec2eb956668a2448d3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3cab32b283102bfdda6b5acc7cecba"><td class="memItemLeft" align="right" valign="top"><a id="a5d3cab32b283102bfdda6b5acc7cecba"></a>
Type&#160;</td><td class="memItemRight" valign="bottom"><b>m_type</b> {Type::None}</td></tr>
<tr class="separator:a5d3cab32b283102bfdda6b5acc7cecba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb07f80606b888499663957ec2dbe83"><td class="memItemLeft" align="right" valign="top"><a id="afdb07f80606b888499663957ec2dbe83"></a>
Case&#160;</td><td class="memItemRight" valign="bottom"><b>m_case</b> {Case::Lower}</td></tr>
<tr class="separator:afdb07f80606b888499663957ec2dbe83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921aa92aa30c5c3e7172bbb0135652d1"><td class="memItemLeft" align="right" valign="top"><a id="a921aa92aa30c5c3e7172bbb0135652d1"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_size</b> {0}</td></tr>
<tr class="separator:a921aa92aa30c5c3e7172bbb0135652d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac100e4ea2da65e8b67a5087888c25ee0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac100e4ea2da65e8b67a5087888c25ee0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html#ac100e4ea2da65e8b67a5087888c25ee0">operator==</a> (const <a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html">BasicFormatSpecifier</a>&lt; T &gt; &amp;specifier1, const <a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html">BasicFormatSpecifier</a>&lt; T &gt; &amp;specifier2)</td></tr>
<tr class="separator:ac100e4ea2da65e8b67a5087888c25ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename CharType&gt;<br />
struct fly::detail::BasicFormatSpecifier&lt; CharType &gt;</h3>

<p>Structure to encapsulate positional and formatting options (which constitute a replacement field) based strongly upon: </p><pre class="fragment">https://en.cppreference.com/w/cpp/utility/format/format
https://en.cppreference.com/w/cpp/utility/format/formatter#Standard_format_specification
</pre><p> A replacement field has the following format: </p><pre class="fragment">1. An introductory "{" character.
2. An optional non-negative position.
3. An optional colon ":" following by formatting options.
4. A final "}" character.
</pre><p> The postition option specifies the index of the format parameter whose value is to be used for this replacement field. If not specified, the format parameters are used in order. The position option must be specified in all replacements fields or not in any replacement field; mixing of manual and automatic indexing is an error.</p>
<p>Formatting options have the following format, where every field is optional: </p><pre class="fragment">1. An optional fill character (which may be any ASCII character other than "{" or "}"),
   followed by an alignment option. The alignment option may be one of:

   "&lt;" - Forces the field to be aligned to the start of the available space.
   "&gt;" - Forces the field to be aligned to the end of the available space.
   "^" - Forces the field to be centered within the available space.

2. A sign indicator. The sign character may be one of:

   "+" - A sign should be used for both non-negative and negative numbers.
   "-" - A sign should be used for negative numbers only.
   " " - A sign should be used for negative numbers and a leading space should be used
         for non-negative numbers.

3. An alternate form indicator (a literal "#" character). If present, the following alternate
   forms will be used:

   Integral types - If binary, octal, or hexadecimal presentation types are used, the
   alternate form inserts 0b, 0, or 0x prefixes, respectively, before the value.

   Floating point types - A decimal point character will always be inserted even if no digits
   follow it.

4. A zero-padding indicator (a literal "0" character). If present, the value is padded with
   leading zeros. This option is ignored if an alignment option is also specified.

5. A width value. A width is either a positive decimal number or a nested replacement field
   (*). If present, it specifies the minimum field width.

6. A precision value. A precision is a decimal (".") followed by a non-negative decimal
   number or a nested replacement field (*). If present, it specifies the precision or
   maximum field size. It may only be used for the following value types:

   String types - precision specifies the maxiumum number of characters to be used.

   Floating point types - precision specifies the formatting precision.

7. A locale-specific form indicator (a literal "L" character). It may only be used for the
   following value types:

   Integral types - locale-specific form inserts appropriate digit group separator
   characters.

   Floating point types - locale-specific form inserts appropriate digit group and radix
   separator characters.

   Boolean types - locale-specific form uses the appropriate string for textual
   representation.

8. A presentation type. The type determines how the value should be presented, where the
   allowed presentation type varies by value type:

   Character types - Valid presentations: none, "c", b", "B", "o", "d", "x", "X".

   String types - Valid presentations: none, "s".

   Pointer types - Valid presentations: none, "p".

   Integral types - Valid presentations: none, "c", b", "B", "o", "d", "x", "X".

   Floating point types - Valid presentations: none, "a", A", "e", "E", "f", "F", "g", "G".

   Boolean types - Valid presentations: none, "c", s", b", "B", "o", "d", "x", "X".

   Strong enumeration types - If an overload of operator&lt;&lt; is defined, valid presentations
   are: none, "s". Else, valid presentations are: none, "c", b", "B", "o", "d", "x", "X".

   Other (generic) types - Valid presentations: none. An overload of operator&lt;&lt; must be
   defined for generic types.

   For details on each presentation type, see the above links.
</pre><p> (*) Nested replacement fields are a subset of the full replacement field, and may be of the form "{}" or "{n}", where n is an optional non-negative position. The corresponding format parameter must be an integral type. Its value has the same restrictions as the formatting option it is used for.</p>
<dl class="section author"><dt>Author</dt><dd>Timothy Flynn (<a href="#" onclick="location.href='mai'+'lto:'+'trf'+'ly'+'nn8'+'9@'+'pm.'+'me'; return false;">trfly<span style="display: none;">.nosp@m.</span>nn89<span style="display: none;">.nosp@m.</span>@pm.m<span style="display: none;">.nosp@m.</span>e</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>January 3, 2021 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ade3639ff921d74b84fa1cd147cfb4b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3639ff921d74b84fa1cd147cfb4b55">&#9670;&nbsp;</a></span>infer_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharType &gt; </div>
<div class="memtemplate">
template&lt;typename FormatString &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html">fly::detail::BasicFormatSpecifier</a>&lt; CharType &gt;::infer_type </td>
          <td>(</td>
          <td class="paramtype">typename FormatString::ParameterType&#160;</td>
          <td class="paramname"><em>parameter_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Infer a presentation type for a replacement field based on the corresponding format parameter's type.</p>
<p>TODO: This should be private. Once the standard fly::Formatters are updated to inherit from this structure, they may infer their presentation type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FormatString</td><td>The type of the format string containing the replacement field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The format string containing the replacement field. </td></tr>
    <tr><td class="paramname">parameter_type</td><td>The type of format parameter corresponding to the replacement field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a891890010eb57055aa81ea26799c4778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891890010eb57055aa81ea26799c4778">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharType &gt; </div>
<div class="memtemplate">
template&lt;typename FormatString &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html">fly::detail::BasicFormatSpecifier</a>&lt; CharType &gt;::parse </td>
          <td>(</td>
          <td class="paramtype">FormatString &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename FormatString::ParameterType&#160;</td>
          <td class="paramname"><em>parameter_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse the formatting options for a standard replacement field.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FormatString</td><td>The type of the format string containing the replacement field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The format string containing the replacement field. </td></tr>
    <tr><td class="paramname">parameter_type</td><td>The type of format parameter corresponding to the replacement field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed specifier. </dd></dl>

</div>
</div>
<a id="a5603b73b48db558ed07cd728143950af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5603b73b48db558ed07cd728143950af">&#9670;&nbsp;</a></span>precision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharType &gt; </div>
<div class="memtemplate">
template&lt;typename FormatContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html">fly::detail::BasicFormatSpecifier</a>&lt; CharType &gt;::precision </td>
          <td>(</td>
          <td class="paramtype">FormatContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>fallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The precision formatting option may either be a number or a nested replacement field. If a numeric value was specified, return that value. If a nested replacement field was specified, return the value of the format parameter at the position indicated by the nested replacement field.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FormatContext</td><td>The formatting context type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context holding the formatting state. </td></tr>
    <tr><td class="paramname">fallback</td><td>The value to return if neither a number or replacement field was specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The replacement field's resolved precision. </dd></dl>

</div>
</div>
<a id="a7f28faad248b9614607686a088e3a9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f28faad248b9614607686a088e3a9ba">&#9670;&nbsp;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharType &gt; </div>
<div class="memtemplate">
template&lt;typename FormatContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html">fly::detail::BasicFormatSpecifier</a>&lt; CharType &gt;::width </td>
          <td>(</td>
          <td class="paramtype">FormatContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>fallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The width formatting option may either be a number or a nested replacement field. If a numeric value was specified, return that value. If a nested replacement field was specified, return the value of the format parameter at the position indicated by the nested replacement field.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FormatContext</td><td>The formatting context type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context holding the formatting state. </td></tr>
    <tr><td class="paramname">fallback</td><td>The value to return if neither a number or replacement field was specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The replacement field's resolved width. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac100e4ea2da65e8b67a5087888c25ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac100e4ea2da65e8b67a5087888c25ee0">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharType &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html">BasicFormatSpecifier</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>specifier1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html">BasicFormatSpecifier</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>specifier2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare two replacement field instances for equality.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the two instances are equal. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>fly/types/string/detail/<a class="el" href="format__specifier_8hpp_source.html">format_specifier.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>fly</b></li><li class="navelem"><b>detail</b></li><li class="navelem"><a class="el" href="structfly_1_1detail_1_1_basic_format_specifier.html">BasicFormatSpecifier</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
