<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libfly: fly::task::TaskRunner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libfly
   &#160;<span id="projectnumber">6.0.0</span>
   </div>
   <div id="projectbrief">C++20 utility library for Linux, macOS, and Windows</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classfly_1_1task_1_1_task_runner.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classfly_1_1task_1_1_task_runner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fly::task::TaskRunner Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="task__runner_8hpp_source.html">task_runner.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for fly::task::TaskRunner:</div>
<div class="dyncontent">
<div class="center"><img src="classfly_1_1task_1_1_task_runner__inherit__graph.png" border="0" usemap="#afly_1_1task_1_1_task_runner_inherit__map" alt="Inheritance graph"/></div>
<map name="afly_1_1task_1_1_task_runner_inherit__map" id="afly_1_1task_1_1_task_runner_inherit__map">
<area shape="rect" title=" " alt="" coords="137,95,293,121"/>
<area shape="rect" href="classfly_1_1task_1_1_parallel_task_runner.html" title=" " alt="" coords="5,177,209,203"/>
<area shape="rect" href="classfly_1_1task_1_1_sequenced_task_runner.html" title=" " alt="" coords="234,169,415,211"/>
<area shape="rect" title=" " alt="" coords="117,5,313,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for fly::task::TaskRunner:</div>
<div class="dyncontent">
<div class="center"><img src="classfly_1_1task_1_1_task_runner__coll__graph.png" border="0" usemap="#afly_1_1task_1_1_task_runner_coll__map" alt="Collaboration graph"/></div>
<map name="afly_1_1task_1_1_task_runner_coll__map" id="afly_1_1task_1_1_task_runner_coll__map">
<area shape="rect" title=" " alt="" coords="25,95,181,121"/>
<area shape="rect" title=" " alt="" coords="5,5,201,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac29d97c384a905e4bad9f94c31ec4aa9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#ac29d97c384a905e4bad9f94c31ec4aa9">~TaskRunner</a> ()=default</td></tr>
<tr class="separator:ac29d97c384a905e4bad9f94c31ec4aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b1026a1ccf4d588c870792d5d7d7f9"><td class="memTemplParams" colspan="2">template&lt;typename TaskType &gt; </td></tr>
<tr class="memitem:ab1b1026a1ccf4d588c870792d5d7d7f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#ab1b1026a1ccf4d588c870792d5d7d7f9">post_task</a> (<a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;location, TaskType &amp;&amp;task)</td></tr>
<tr class="separator:ab1b1026a1ccf4d588c870792d5d7d7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db81b1dbde732c6dd024e7814295c57"><td class="memTemplParams" colspan="2">template&lt;typename OwnerType , typename TaskType &gt; </td></tr>
<tr class="memitem:a0db81b1dbde732c6dd024e7814295c57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#a0db81b1dbde732c6dd024e7814295c57">post_task</a> (<a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;location, std::weak_ptr&lt; OwnerType &gt; weak_owner, TaskType &amp;&amp;task)</td></tr>
<tr class="separator:a0db81b1dbde732c6dd024e7814295c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe2592399d88f2060afb16a55846433"><td class="memTemplParams" colspan="2">template&lt;typename TaskType , typename ReplyType &gt; </td></tr>
<tr class="memitem:aefe2592399d88f2060afb16a55846433"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#aefe2592399d88f2060afb16a55846433">post_task_with_reply</a> (<a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;location, TaskType &amp;&amp;task, ReplyType &amp;&amp;reply)</td></tr>
<tr class="separator:aefe2592399d88f2060afb16a55846433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bbca670ff3bfbb1fbc2a343d6c750c"><td class="memTemplParams" colspan="2">template&lt;typename OwnerType , typename TaskType , typename ReplyType &gt; </td></tr>
<tr class="memitem:a10bbca670ff3bfbb1fbc2a343d6c750c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#a10bbca670ff3bfbb1fbc2a343d6c750c">post_task_with_reply</a> (<a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;location, std::weak_ptr&lt; OwnerType &gt; weak_owner, TaskType &amp;&amp;task, ReplyType &amp;&amp;reply)</td></tr>
<tr class="separator:a10bbca670ff3bfbb1fbc2a343d6c750c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c999cfd82a3ebc380cf1358b851e873"><td class="memTemplParams" colspan="2">template&lt;typename TaskType &gt; </td></tr>
<tr class="memitem:a3c999cfd82a3ebc380cf1358b851e873"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#a3c999cfd82a3ebc380cf1358b851e873">post_task_with_delay</a> (<a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;location, std::chrono::milliseconds delay, TaskType &amp;&amp;task)</td></tr>
<tr class="separator:a3c999cfd82a3ebc380cf1358b851e873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dfecddb4570c1d3e54cdff0a3e6253"><td class="memTemplParams" colspan="2">template&lt;typename OwnerType , typename TaskType &gt; </td></tr>
<tr class="memitem:a14dfecddb4570c1d3e54cdff0a3e6253"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#a14dfecddb4570c1d3e54cdff0a3e6253">post_task_with_delay</a> (<a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;location, std::weak_ptr&lt; OwnerType &gt; weak_owner, std::chrono::milliseconds delay, TaskType &amp;&amp;task)</td></tr>
<tr class="separator:a14dfecddb4570c1d3e54cdff0a3e6253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a3e604f3c0a301051b83537598d617"><td class="memTemplParams" colspan="2">template&lt;typename TaskType , typename ReplyType &gt; </td></tr>
<tr class="memitem:a99a3e604f3c0a301051b83537598d617"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#a99a3e604f3c0a301051b83537598d617">post_task_with_delay_and_reply</a> (<a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;location, std::chrono::milliseconds delay, TaskType &amp;&amp;task, ReplyType &amp;&amp;reply)</td></tr>
<tr class="separator:a99a3e604f3c0a301051b83537598d617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88d08863b2a51eb6ee1eb7bc60edafa"><td class="memTemplParams" colspan="2">template&lt;typename OwnerType , typename TaskType , typename ReplyType &gt; </td></tr>
<tr class="memitem:aa88d08863b2a51eb6ee1eb7bc60edafa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#aa88d08863b2a51eb6ee1eb7bc60edafa">post_task_with_delay_and_reply</a> (<a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;location, std::weak_ptr&lt; OwnerType &gt; weak_owner, std::chrono::milliseconds delay, TaskType &amp;&amp;task, ReplyType &amp;&amp;reply)</td></tr>
<tr class="separator:aa88d08863b2a51eb6ee1eb7bc60edafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a49fd588798623952dc99f6dd9e6eae3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#a49fd588798623952dc99f6dd9e6eae3f">TaskRunner</a> (std::shared_ptr&lt; <a class="el" href="classfly_1_1task_1_1_task_manager.html">TaskManager</a> &gt; task_manager) noexcept</td></tr>
<tr class="separator:a49fd588798623952dc99f6dd9e6eae3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8c1e225ef2b8ffcf7d8f754a277190"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#adf8c1e225ef2b8ffcf7d8f754a277190">post_task_internal</a> (<a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;location, Task &amp;&amp;task)=0</td></tr>
<tr class="separator:adf8c1e225ef2b8ffcf7d8f754a277190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dc3a90a3b94fcd9617a0efd6aa6df1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#a94dc3a90a3b94fcd9617a0efd6aa6df1">task_complete</a> (<a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;location)=0</td></tr>
<tr class="separator:a94dc3a90a3b94fcd9617a0efd6aa6df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acb50d9b5c6b873021296e756fa32f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#a4acb50d9b5c6b873021296e756fa32f3">post_task_to_task_manager</a> (<a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;location, Task &amp;&amp;task)</td></tr>
<tr class="separator:a4acb50d9b5c6b873021296e756fa32f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e063ea386334b6fe29d47dc7419fe4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfly_1_1task_1_1_task_runner.html#a99e063ea386334b6fe29d47dc7419fe4">post_task_to_task_manager_with_delay</a> (<a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;location, std::chrono::milliseconds delay, Task &amp;&amp;task)</td></tr>
<tr class="separator:a99e063ea386334b6fe29d47dc7419fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abfd65c2d85c5faff5c12fd032cc5cf0a"><td class="memItemLeft" align="right" valign="top"><a id="abfd65c2d85c5faff5c12fd032cc5cf0a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TaskManager</b></td></tr>
<tr class="separator:abfd65c2d85c5faff5c12fd032cc5cf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for controlling the execution of tasks. Concrete task runners control the ordering and execution of tasks.</p>
<p>Tasks may generally be any callable type (lambda, std::function, etc.). Specific posting methods may place restrictions on the callable type, on either the return type of the invocation or the arguments the task accepts.</p>
<p>Tasks whose result is a non-void type may pass their result to a reply task. For example: </p><pre class="fragment">  auto task = []() -&gt; int
  {
      // Task body here.
      return 12389;
  };

  auto reply = [](int task_result)
  {
      assert(task_result == 12389);
      // Reply body here.
  };

  task_runner-&gt;post_task_with_reply(FROM_HERE, std::move(task), std::move(reply));
</pre><p> Tasks whose result is void may indicate their completion to a reply task. For example: </p><pre class="fragment">  auto task = []()
  {
      // Task body here.
  };

  auto reply = []()
  {
      // Reply body here.
  };

  task_runner-&gt;post_task_with_reply(FROM_HERE, std::move(task), std::move(reply));
</pre><p> Mismatching of task result types and reply parameter types is explicitly forbidden at compile time. Tasks that return a non-void result must be paired with a reply which is invocable with only that type. Tasks which return void must be paired with a reply that is invocable without arguments.</p>
<p>Reply tasks are not executed immediately after a task is complete. Rather, they are posted for execution on the same task runner on which that task was posted.</p>
<p>Once a task is posted, it may be attempted to be cancelled in a number of ways:</p>
<ol type="1">
<li><p class="startli">Use one of the posting methods which accepts a weak pointer to the owner of the task. When the task is ready to be executed, if the weak pointer cannot be promoted to a strong pointer, the task is dropped. The task must accept a single argument, the shared pointer obtained from the weak pointer. For example:</p>
<p class="startli">auto task = [](std::shared_ptr&lt;MyClass&gt; self) { // Task body here. };</p>
<p class="startli">std::weak_ptr&lt;MyClass&gt; weak_self = shared_from_this(); task_runner-&gt;post_task(FROM_HERE, weak_self, std::move(task));</p>
<p class="startli">Reply tasks may be cancelled in the same manner. The reply task must then accept the result of the task and the shared pointer obtained from the weak pointer. If the task was dropped due to being unable to promote the weak pointer, the reply is also dropped. If the task was executed, when the reply is ready to be executed, if the weak pointer cannot be promoted to a strong pointer, the reply is dropped. For example:</p>
<p class="startli">auto task = [](std::shared_ptr&lt;MyClass&gt; self) -&gt; int { // Task body here. return 12389; };</p>
<p class="startli">auto reply = [](int task_result, std::shared_ptr&lt;MyClass&gt; self) { assert(task_result == 12389); // Reply body here. };</p>
<p class="startli">std::weak_ptr&lt;MyClass&gt; weak_self = shared_from_this(); task_runner-&gt;post_task_with_reply(FROM_HERE, weak_self, std::move(task), std::move(reply));</p>
</li>
<li>Deleting the task runner onto which the task was posted. This will only cancel the task if the task manager has not yet instructed the task runner to execute the task.</li>
</ol>
<dl class="section author"><dt>Author</dt><dd>Timothy Flynn (<a href="#" onclick="location.href='mai'+'lto:'+'trf'+'ly'+'nn8'+'9@'+'pm.'+'me'; return false;">trfly<span style="display: none;">.nosp@m.</span>nn89<span style="display: none;">.nosp@m.</span>@pm.m<span style="display: none;">.nosp@m.</span>e</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>August 12, 2018 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac29d97c384a905e4bad9f94c31ec4aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29d97c384a905e4bad9f94c31ec4aa9">&#9670;&nbsp;</a></span>~TaskRunner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual fly::task::TaskRunner::~TaskRunner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="a49fd588798623952dc99f6dd9e6eae3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fd588798623952dc99f6dd9e6eae3f">&#9670;&nbsp;</a></span>TaskRunner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fly::task::TaskRunner::TaskRunner </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classfly_1_1task_1_1_task_manager.html">TaskManager</a> &gt;&#160;</td>
          <td class="paramname"><em>task_manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Private constructor. Task runners may only be created by the task manager.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_manager</td><td>The task manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0db81b1dbde732c6dd024e7814295c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db81b1dbde732c6dd024e7814295c57">&#9670;&nbsp;</a></span>post_task() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OwnerType , typename TaskType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fly::task::TaskRunner::post_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::weak_ptr&lt; OwnerType &gt;&#160;</td>
          <td class="paramname"><em>weak_owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaskType &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Post a task for execution with protection by the provided weak pointer. The task may be any callable type which accepts a single argument, a locked shared pointer obtained from the weak pointer. When the task is ready to be executed, if the weak pointer fails to be locked, the task is dropped.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TaskType</td><td>Callable type of the task. </td></tr>
    <tr><td class="paramname">OwnerType</td><td>Type of the owner of the task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location from which the task was posted (use FROM_HERE). </td></tr>
    <tr><td class="paramname">weak_owner</td><td>A weak pointer to the owner of the task. </td></tr>
    <tr><td class="paramname">task</td><td>The task to be executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the task was posted for execution. </dd></dl>

</div>
</div>
<a id="ab1b1026a1ccf4d588c870792d5d7d7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b1026a1ccf4d588c870792d5d7d7f9">&#9670;&nbsp;</a></span>post_task() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TaskType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fly::task::TaskRunner::post_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaskType &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Post a task for execution. The task may be any callable type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TaskType</td><td>Callable type of the task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location from which the task was posted (use FROM_HERE). </td></tr>
    <tr><td class="paramname">task</td><td>The task to be executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the task was posted for execution. </dd></dl>

</div>
</div>
<a id="adf8c1e225ef2b8ffcf7d8f754a277190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8c1e225ef2b8ffcf7d8f754a277190">&#9670;&nbsp;</a></span>post_task_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool fly::task::TaskRunner::post_task_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Post a task for execution in accordance with the concrete task runner's policy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location from which the task was posted. </td></tr>
    <tr><td class="paramname">task</td><td>The task to be executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the task was posted for execution. </dd></dl>

<p>Implemented in <a class="el" href="classfly_1_1task_1_1_sequenced_task_runner.html#a3ddb3ce7eeec139341dc29ad042e4928">fly::task::SequencedTaskRunner</a>, and <a class="el" href="classfly_1_1task_1_1_parallel_task_runner.html#a400eeec3f9034e275469f070e2aacf25">fly::task::ParallelTaskRunner</a>.</p>

</div>
</div>
<a id="a4acb50d9b5c6b873021296e756fa32f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acb50d9b5c6b873021296e756fa32f3">&#9670;&nbsp;</a></span>post_task_to_task_manager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fly::task::TaskRunner::post_task_to_task_manager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Forward a task to the task manager to be executed as soon as a worker thread is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location from which the task was posted. </td></tr>
    <tr><td class="paramname">task</td><td>The task to be executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the task was posted for execution. </dd></dl>

</div>
</div>
<a id="a99e063ea386334b6fe29d47dc7419fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e063ea386334b6fe29d47dc7419fe4">&#9670;&nbsp;</a></span>post_task_to_task_manager_with_delay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fly::task::TaskRunner::post_task_to_task_manager_with_delay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Forward a task to the task manager to be scheduled for excution after a delay. The task will be stored on the task manager's timer thread. Once the given delay has expired, the task will be handed back to the task runner to govern when the task will be posted from there.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location from which the task was posted. </td></tr>
    <tr><td class="paramname">delay</td><td>Delay before posting the task. </td></tr>
    <tr><td class="paramname">task</td><td>The task to be executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the task was posted for delayed execution. </dd></dl>

</div>
</div>
<a id="a3c999cfd82a3ebc380cf1358b851e873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c999cfd82a3ebc380cf1358b851e873">&#9670;&nbsp;</a></span>post_task_with_delay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TaskType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fly::task::TaskRunner::post_task_with_delay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaskType &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedule a task to be posted after a delay. The task may be any callable type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TaskType</td><td>Callable type of the task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location from which the task was posted (use FROM_HERE). </td></tr>
    <tr><td class="paramname">delay</td><td>Delay before posting the task. </td></tr>
    <tr><td class="paramname">task</td><td>The task to be executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the task was posted for delayed execution. </dd></dl>

</div>
</div>
<a id="a14dfecddb4570c1d3e54cdff0a3e6253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14dfecddb4570c1d3e54cdff0a3e6253">&#9670;&nbsp;</a></span>post_task_with_delay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OwnerType , typename TaskType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fly::task::TaskRunner::post_task_with_delay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::weak_ptr&lt; OwnerType &gt;&#160;</td>
          <td class="paramname"><em>weak_owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaskType &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedule a task to be posted after a delay with protection by the provided weak pointer. The task may be any callable type which accepts a single argument, a locked shared pointer obtained from the weak pointer. When the task is ready to be executed, if the weak pointer fails to be locked, the task is dropped.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TaskType</td><td>Callable type of the task. </td></tr>
    <tr><td class="paramname">OwnerType</td><td>Type of the owner of the task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location from which the task was posted (use FROM_HERE). </td></tr>
    <tr><td class="paramname">weak_owner</td><td>A weak pointer to the owner of the task. </td></tr>
    <tr><td class="paramname">delay</td><td>Delay before posting the task. </td></tr>
    <tr><td class="paramname">task</td><td>The task to be executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the task was posted for delayed execution. </dd></dl>

</div>
</div>
<a id="a99a3e604f3c0a301051b83537598d617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a3e604f3c0a301051b83537598d617">&#9670;&nbsp;</a></span>post_task_with_delay_and_reply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TaskType , typename ReplyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fly::task::TaskRunner::post_task_with_delay_and_reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaskType &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>reply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedule a task to be posted after a delay. The task may be any callable type.</p>
<p>When the task has been executed, the reply task is then posted for execution on this same task runner. The reply task may be any callable type that is invocable with the return type of the task (if non-void), or without any arguments (if void).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TaskType</td><td>Callable type of the task. </td></tr>
    <tr><td class="paramname">ReplyType</td><td>Callable type of the reply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location from which the task was posted (use FROM_HERE). </td></tr>
    <tr><td class="paramname">delay</td><td>Delay before posting the task. </td></tr>
    <tr><td class="paramname">task</td><td>The task to be executed. </td></tr>
    <tr><td class="paramname">reply</td><td>The reply to be executed with the result of the task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the task was posted for execution. </dd></dl>

</div>
</div>
<a id="aa88d08863b2a51eb6ee1eb7bc60edafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88d08863b2a51eb6ee1eb7bc60edafa">&#9670;&nbsp;</a></span>post_task_with_delay_and_reply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OwnerType , typename TaskType , typename ReplyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fly::task::TaskRunner::post_task_with_delay_and_reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::weak_ptr&lt; OwnerType &gt;&#160;</td>
          <td class="paramname"><em>weak_owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaskType &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>reply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedule a task to be posted after a delay with protection by the provided weak pointer. The task may be any callable type which accepts a single argument, a locked shared pointer obtained from the weak pointer. When the task is ready to be executed, if the weak pointer fails to be locked, the task is dropped.</p>
<p>When the task has been executed, the reply task is then posted for execution on this same task runner with protection by the same weak pointer. The reply task may be any callable type that is invocable with the return type of the task (if non-void) and a locked shared pointer obtained from the weak pointer, or with only the locked shared pointer. When the reply is ready to be executed, if the weak pointer fails to be locked, the reply is dropped.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TaskType</td><td>Callable type of the task. </td></tr>
    <tr><td class="paramname">ReplyType</td><td>Callable type of the reply. </td></tr>
    <tr><td class="paramname">OwnerType</td><td>Type of the owner of the task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location from which the task was posted (use FROM_HERE). </td></tr>
    <tr><td class="paramname">weak_owner</td><td>A weak pointer to the owner of the task. </td></tr>
    <tr><td class="paramname">delay</td><td>Delay before posting the task. </td></tr>
    <tr><td class="paramname">task</td><td>The task to be executed. </td></tr>
    <tr><td class="paramname">reply</td><td>The reply to be executed with the result of the task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the task was posted for execution. </dd></dl>

</div>
</div>
<a id="a10bbca670ff3bfbb1fbc2a343d6c750c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10bbca670ff3bfbb1fbc2a343d6c750c">&#9670;&nbsp;</a></span>post_task_with_reply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OwnerType , typename TaskType , typename ReplyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fly::task::TaskRunner::post_task_with_reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::weak_ptr&lt; OwnerType &gt;&#160;</td>
          <td class="paramname"><em>weak_owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaskType &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>reply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Post a task for execution with protection by the provided weak pointer. The task may be any callable type which accepts a single argument, a locked shared pointer obtained from the weak pointer. When the task is ready to be executed, if the weak pointer fails to be locked, the task is dropped.</p>
<p>When the task has been executed, the reply task is then posted for execution on this same task runner with protection by the same weak pointer. The reply task may be any callable type that is invocable with the return type of the task (if non-void) and a locked shared pointer obtained from the weak pointer, or with only the locked shared pointer. When the reply is ready to be executed, if the weak pointer fails to be locked, the reply is dropped.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TaskType</td><td>Callable type of the task. </td></tr>
    <tr><td class="paramname">ReplyType</td><td>Callable type of the reply. </td></tr>
    <tr><td class="paramname">OwnerType</td><td>Type of the owner of the task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location from which the task was posted (use FROM_HERE). </td></tr>
    <tr><td class="paramname">weak_owner</td><td>A weak pointer to the owner of the task. </td></tr>
    <tr><td class="paramname">task</td><td>The task to be executed. </td></tr>
    <tr><td class="paramname">reply</td><td>The reply to be executed with the result of the task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the task was posted for execution. </dd></dl>

</div>
</div>
<a id="aefe2592399d88f2060afb16a55846433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe2592399d88f2060afb16a55846433">&#9670;&nbsp;</a></span>post_task_with_reply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TaskType , typename ReplyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fly::task::TaskRunner::post_task_with_reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaskType &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>reply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Post a task for execution. The task may be any callable type.</p>
<p>When the task has been executed, the reply task is then posted for execution on this same task runner. The reply task may be any callable type that is invocable with the return type of the task (if non-void), or without any arguments (if void).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TaskType</td><td>Callable type of the task. </td></tr>
    <tr><td class="paramname">ReplyType</td><td>Callable type of the reply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location from which the task was posted (use FROM_HERE). </td></tr>
    <tr><td class="paramname">task</td><td>The task to be executed. </td></tr>
    <tr><td class="paramname">reply</td><td>The reply to be executed with the result of the task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the task was posted for execution. </dd></dl>

</div>
</div>
<a id="a94dc3a90a3b94fcd9617a0efd6aa6df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94dc3a90a3b94fcd9617a0efd6aa6df1">&#9670;&nbsp;</a></span>task_complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void fly::task::TaskRunner::task_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfly_1_1task_1_1_task_location.html">TaskLocation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Completion notification triggered by the task manager that a task has finished execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location from which the task was posted. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classfly_1_1task_1_1_sequenced_task_runner.html#a853da00aaee50184f422662e308038c2">fly::task::SequencedTaskRunner</a>, and <a class="el" href="classfly_1_1task_1_1_parallel_task_runner.html#ac9299bd5279bea968b2449c9ddb28cd0">fly::task::ParallelTaskRunner</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>fly/task/<a class="el" href="task__runner_8hpp_source.html">task_runner.hpp</a></li>
<li>fly/task/task_runner.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>fly</b></li><li class="navelem"><b>task</b></li><li class="navelem"><a class="el" href="classfly_1_1task_1_1_task_runner.html">TaskRunner</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
